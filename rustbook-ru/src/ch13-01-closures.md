<!-- Old heading. Do not remove or links may break. -->

<a id="closures-anonymous-functions-that-can-capture-their-environment"></a>

## Закрытия: Анонимные функции, подхватывающие своё окружение

Замыкания в Rust - это анонимные функции, которые можно сохранять в переменных или передавать в качестве аргументов другим функциям. Вы можете создать замыкание в одном месте, а затем вызвать его в каком-нибудь другом, чтобы выполнить обработку в другом контексте. В отличие от функций, замыкания могут использовать значения из области видимости, в которой они были определены. Мы продемонстрируем, как эти возможности замыканий позволяют повторно использовать код и изменять поведение.

<!-- Old headings. Do not remove or links may break. -->

<a id="creating-an-abstraction-of-behavior-with-closures"></a>
<a id="refactoring-using-functions"></a>
<a id="refactoring-with-closures-to-store-code"></a>

### Захват переменных окружения с помощью замыкания

Сначала мы рассмотрим, как можно использовать замыкания для фиксирования значений среды, в которой они определены, для последующего использования. Вот сценарий: Время от времени наша компания по производству футболок выдаёт эксклюзивную футболку, выпущенную ограниченным тиражом, кому-то из нашего списка рассылки в качестве рекламной акции. Люди в списке рассылки могут по желанию добавить свой любимый цвет в свой профиль. Если человек, выбранный для получения бесплатной футболки, указал свой любимый цвет, он получает футболку этого цвета. Если человек не указал свой любимый цвет, он получит рубашку того цвета, которых в данный момент у компании больше всего.

Существует множество способов реализовать это. В данном примере мы будем использовать перечисление `ShirtColor`, которое имеет варианты `Red` и `Blue` (для простоты ограничим количество доступных цветов). Запасы компании мы представим структурой `Inventory`, которая имеет поле `shirts`, содержащее `Vec<ShirtColor>`, который содержит цвета рубашек, имеющихся на складе. Метод `giveaway`, определённый у `Inventory`, получает опциональный цвет рубашки, который предпочитает обладатель бесплатной рубашки, и возвращает цвет рубашки, которую он получит. Эта схема показана в листинге 13-1:

<span class="filename">Файл: src/main.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-01/src/main.rs}}
```

<span class="caption">Листинг 13-1: Ситуация с раздачей рубашек компанией</span>

В магазине `store`, определённом в `main`, осталось две синие и одна красная рубашки для этой ограниченной акции. Мы вызываем метод `giveaway` для пользователя предпочитающего красную рубашку и для пользователя без каких-либо предпочтений.

Опять же, этот код мог быть реализован множеством способов, но в данном случае, чтобы сосредоточиться на замыканиях, мы придерживались изученных ранее концепций, за исключением тела метода `giveaway`, в котором используется замыкание. В методе `giveaway` мы получаем пользовательское предпочтение цвета как параметр типа `Option<ShirtColor>` и вызываем метод `unwrap_or_else` на `user_preference`. Метод <a data-md-type="raw_html" href="../std/option/enum.Option.html#method.unwrap_or_else">`unwrap_or_else` на `Option<T>`</a><!-- ignore --> определён стандартной библиотекой. Он принимает один аргумент: замыкание без аргументов, которое возвращает значение `T` (тот же тип, который хранится в `Some` варианта `Option<T>`, в данном случае `ShirtColor`). Если `Option<T>` является вариантом `Some`, `unwrap_or_else` возвращает значение из `Some`. Если `Option<T>` является вариантом `None`, `unwrap_or_else` вызывает замыкание и вернёт значение, возвращённое замыканием.

В качестве аргумента `unwrap_or_else` мы передаём замыкание `|| self.most_stocked()`. Это замыкание, которое само не принимает никаких параметров (если бы у замыкания были параметры, они появились бы между двумя вертикальными полосами). В теле замыкания вызывается `self.most_stocked()`. Здесь мы определили замыкание, а реализация `unwrap_or_else` такова, что выполнится оно позднее, когда потребуется получить результат.

Выполнение этого кода выводит:

```console
{{#include ../listings/ch13-functional-features/listing-13-01/output.txt}}
```

Интересным аспектом здесь является то, что мы передали замыкание, которое вызывает `self.most_stocked()` текущего экземпляра `Inventory`. Стандартной библиотеке не нужно знать ничего о типах `Inventory` или `ShirtColor`, которые мы определили, или о логике, которую мы хотим использовать в этом сценарии. Замыкание фиксирует неизменяемую ссылку на `self` `Inventory` и передаёт её с указанным нами кодом в метод `unwrap_or_else`. А вот функции не могут фиксировать своё окружение таким образом.

### Выведение и аннотация типов замыкания

Есть и другие различия между функциями и замыканиями. Замыкания обычно не требуют аннотирования типов параметров или возвращаемого значения, как это делается в функциях `fn`. Аннотации типов требуются для функций, потому что типы являются частью явного интерфейса, предоставляемого пользователям. Жёсткое определение этого интерфейса важно для того, чтобы все согласились с тем, какие типы значений использует и возвращает функция. С другой стороны, замыкания не используются подобным образом: они хранятся в переменных и используются без указания их имён и не предоставляются для использования пользователям нашей библиотеки.

Замыкания, как правило, короткие и уместны только в узком контексте, а не в произвольном сценарии. В этих ограниченных контекстах компилятор может вывести типы параметров и возвращаемого типа, подобно тому, как он может вывести типы большинства переменных (есть редкие случаи, когда компилятору также нужны аннотации типов замыканий).

Как и в случае с переменными, мы можем добавить аннотации типов, если хотим повысить ясность и чёткость описания ценой большей многословности, чем это необходимо. Аннотирование типов для замыкания будет выглядеть как определение, показанное в листинге 13-2. В этом примере мы определяем замыкание и храним его в переменной, а не определяем замыкание в том месте, куда мы передаём его в качестве аргумента, как это было в листинге 13-1.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-02/src/main.rs:here}}
```

<span class="caption">Листинг 13-2: Добавление необязательных аннотаций типов параметров и возвращаемых значений в замыкании</span>

С добавлением аннотаций типов синтаксис замыканий выглядит более похожим на синтаксис функций. Здесь мы определяем функцию, которая добавляет 1 к своему параметру, и замыкание, которое имеет такое же поведение, для сравнения. Мы добавили несколько пробелов, чтобы выровнять соответствующие части. Это показывает, что синтаксис замыкания похож на синтаксис функции, за исключением использования труб (вертикальная черта) и количества необязательного синтаксиса:

```rust,ignore
fn  add_one_v1   (x: u32) -> u32 { x + 1 }
let add_one_v2 = |x: u32| -> u32 { x + 1 };
let add_one_v3 = |x|             { x + 1 };
let add_one_v4 = |x|               x + 1  ;
```

В первой строке показано определение функции, а во второй - полностью аннотированное определение замыкания. В третьей строке мы удаляем аннотации типов из определения замыкания. В четвёртой строке мы убираем скобки, которые являются необязательными, поскольку тело замыкания имеет только одно выражение. Это все правильные определения, которые будут иметь одинаковое поведение при вызове. Строки `add_one_v3` и `add_one_v4` требуют, чтобы замыкания были вычислены до компиляции, поскольку типы будут выведены из их использования. Это похоже на `let v = Vec::new();`, когда в `Vec` необходимо вставить либо аннотации типов, либо значения некоторого типа, чтобы Rust смог вывести тип.

Для определений замыкания компилятор выводит один конкретный тип для каждого из параметров и для возвращаемого значения. Например, в листинге 13-3 показано определение короткого замыкания, которое просто возвращает значение, полученное в качестве параметра. Это замыкание не очень полезно, кроме как для целей данного примера. Обратите внимание, что мы не добавили в определение никаких аннотаций типов. Поскольку аннотаций типов нет, мы можем вызвать замыкание с любым типом, что мы и сделали в первый раз с `String`. Если затем мы попытаемся вызвать `example_closure` с целым числом, мы получим ошибку.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-03/src/main.rs:here}}
```

<span class="caption">Листинг 13-3: Попытка вызова замыкания, типы которого выводятся из двух разных типов</span>

Компилятор вернёт нам вот такую ошибку:

```console
{{#include ../listings/ch13-functional-features/listing-13-03/output.txt}}
```

При первом вызове `example_closure` со значением `String` компилятор определяет тип `x` и возвращаемый тип замыкания как `String`. Эти типы затем фиксируются в замыкании в `example_closure`, и мы получаем ошибку типа при следующей попытке использовать другой тип с тем же замыканием.

### Захват ссылок или передача владения

Замыкания могут захватывать значения из своего окружения тремя способами, которые непосредственно соответствуют трём способам, которыми функция может принимать параметр: неизменное заимствование, мутабельное заимствование и принятие права собственности. Замыкание будет решать, какой из этих способов использовать, основываясь на том, что тело функции делает с полученными значениями.

В листинге 13-4 мы определяем замыкание, которое захватывает неизменяемую ссылку на вектор с именем `list`, поскольку неизменяемая ссылка нужна только для печати значения:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-04/src/main.rs}}
```

<span class="caption">Листинг 13-4: Определение и вызов замыкания, которое захватывает неизменяемую ссылку</span>

Этот пример также иллюстрирует, что переменная может связываться с определением замыкания, и мы можем позже вызвать замыкание, используя имя переменной и круглые скобки, как если бы имя переменной было именем функции.

Поскольку мы можем одновременно иметь несколько неизменяемых ссылок на `list`, `list` по-прежнему доступен из кода до определения замыкания, после определения замыкания, но до вызова замыкания, и после вызова замыкания. Этот код компилируется, выполняется и печатается:

```console
{{#include ../listings/ch13-functional-features/listing-13-04/output.txt}}
```

Затем в листинге 13.5 мы меняем тело замыкания, чтобы оно добавляло элемент в вектор `list` . Теперь замыкание фиксирует изменяемую ссылку:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-05/src/main.rs}}
```

<span class="caption">Листинг 13-5. Определение и вызов замыкания, захватывающего изменяемую ссылку</span>

Этот код компилируется, запускается и печатает:

```console
{{#include ../listings/ch13-functional-features/listing-13-05/output.txt}}
```

Обратите внимание, что между определением и вызовом замыкания `borrows_mutably` больше нет `println!`: когда определяется `borrows_mutably`, оно захватывает мутабельную ссылку на `list`. После вызова замыкания мы больше не используем его, поэтому заимствование mutable заканчивается. Между определением замыкания и вызовом замыкания неизменяемое заимствование для печати недопустимо, потому что при наличии изменяемого заимствования никакие другие заимствования недопустимы. Попробуйте добавить туда `println!` и посмотрите, какое сообщение об ошибке вы получите!

Если вы хотите заставить замыкание взять владение значениями, которые оно использует в окружении, даже если тело замыкания не требует владения, вы можете использовать ключевое слово `move` перед списком параметров.

Эта техника в основном полезна при передаче замыкания новому потоку, чтобы переместить данные так, чтобы они принадлежали новому потоку. Мы подробно обсудим потоки и то, зачем их использовать, в главе 16, когда будем говорить о параллелизме, а пока давайте вкратце рассмотрим порождение нового потока с помощью замыкания, в котором используется ключевое слово `move`. В листинге 13-6 показан код из листинга 13-4, модифицированный для печати вектора в новом потоке, а не в основном потоке:

<span class="filename">Файл : src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-06/src/main.rs}}
```

<span class="caption">Листинг 13-6: Использование <code>move</code> для принуждения замыкания потока принять на себя владение <code>list</code></span>

Мы порождаем новый поток, передавая ему в качестве аргумента замыкание для выполнения. Тело замыкания распечатывает список. В листинге 13-4 замыкание захватило `list` только с помощью неизменяемой ссылки, потому что это минимально необходимый доступ к `list` для его печати. В этом примере, несмотря на то, что тело замыкания по-прежнему требует только неизменяемой ссылки, нам нужно указать, что `list` должен быть перемещён в замыкание, поместив ключевое слово `move` в начало определения замыкания. Новый поток может завершиться раньше, чем завершится основной поток, или основной поток может завершиться первым. Если основной поток сохранил владение `list`, но завершился раньше нового потока и сбросил `list`, неизменяемая ссылка в потоке будет недействительной. Поэтому компилятор требует, чтобы `list` был перемещён в замыкание, переданное новому потоку, чтобы ссылка была действительной. Попробуйте убрать ключевое слово `move` или использовать `list` в основном потоке после определения замыкания и посмотрите, какие ошибки компилятора вы получите!

<!-- Old headings. Do not remove or links may break. -->

<a id="storing-closures-using-generic-parameters-and-the-fn-traits"></a>
<a id="limitations-of-the-cacher-implementation"></a>
<a id="moving-captured-values-out-of-the-closure-and-the-fn-traits"></a>

### Перемещение захваченных значений из замыканий и трейты `Fn`

После того, как замыкание захватило ссылку или владение значением из среды, в которой оно определено (тем самым влияя на то, что перемещается *в* замыкание), код в теле замыкания определяет, что происходит со ссылками или значениями, в момент последующего выполнения замыкания (тем самым влияя на то, что перемещается *из* замыкания). Тело замыкания может делать любое из следующих действий: перемещать захваченное значение из замыкания, изменять захваченное значение, не перемещать и не изменять значение или вообще ничего не захватывать из среды.

То, как замыкание получает и обрабатывает значения из среды, влияет на то, какие трейты реализует замыкание, а трейты - это то, как функции и структуры могут указывать, какие типы замыканий они могут использовать. Замыкания автоматически реализуют один, два или все три из этих `Fn` признаков, аддитивным образом, в зависимости от того, как тело замыкания обрабатывает значения:

1. `FnOnce` применяется к замыканиям, которые могут быть вызваны один раз. Все замыкания реализуют по крайней мере этот трейт, потому что все замыкания могут быть вызваны. Замыкание, которое перемещает захваченные значения из своего тела, реализует только `FnOnce` и ни один из других признаков `Fn`, потому что оно может быть вызвано только один раз.
2. `FnMut` применяется к замыканиям, которые не перемещают захваченные значения из своего тела, но могут изменять захваченные значения. Эти закрытия могут вызываться более одного раза.
3. `Fn` применяется к замыканиям, которые не перемещают захваченные значения из своего тела и не изменяют захваченные значения, а также к замыканиям, которые ничего не захватывают из своего окружения. Эти замыкания можно вызывать более одного раза без изменения окружения, что важно в таких случаях, как одновременный вызов замыкания несколько раз.

Давайте рассмотрим определение метода `unwrap_or_else` на `Option<T>`, который мы использовали в листинге 13-1:

```rust,ignore
impl<T> Option<T> {
    pub fn unwrap_or_else<F>(self, f: F) -> T
    where
        F: FnOnce() -> T
    {
        match self {
            Some(x) => x,
            None => f(),
        }
    }
}
```

Напомним, что `T` - это общий тип, отображающий тип значения в `Some` варианте `Option`. Этот тип `T` также является возвращаемым типом функции `unwrap_or_else`: код, вызывающий `unwrap_or_else` на `Option<String>`, например, получит `String`.

Далее, обратите внимание, что функция `unwrap_or_else` имеет дополнительный параметр общего типа `F`. Тип `F` - это тип параметра `f`, который является замыканием, которое мы задаём при вызове `unwrap_or_else`.

Ограничение, заданное для общего типа `F`, - это `FnOnce() -> T`, что означает, что `F` должен вызываться один раз, не принимать аргументов и возвращать `T`. Использование `FnOnce` в ограничении трейта выражает ограничение того, что `unwrap_or_else` будет вызывать `f` не более одного раза. В теле `unwrap_or_else` мы видим, что если `Option` равно `Some`, то `f` вызываться не будет. Если `Option` будет равен `None`, `f` будет вызван один раз. Поскольку все замыкания реализуют `FnOnce`, `unwrap_or_else` принимает самые разные виды замыканий и является настолько гибким, насколько это возможно.

> Примечание: Функции также могут реализовывать все три признака `Fn`. Если то, что мы хотим сделать, не требует захвата значения из среды, мы можем использовать имя функции, а не замыкания, когда нам нужно что-то, реализующее один из признаков `Fn`. Например, для значения `Option<Vec<T>>` мы можем вызвать `unwrap_or_else(Vec::new)`, чтобы получить новый пустой вектор, если значение равно `None`.

Теперь рассмотрим метод стандартной библиотеки `sort_by_key`, определённый для срезов, чтобы увидеть, чем он отличается от `unwrap_or_else` и почему `sort_by_key` использует `FnMut` вместо `FnOnce` для ограничения трейта. Замыкание получает один аргумент в виде ссылки на текущий элемент в рассматриваемом срезе и возвращает значение типа `K`, которое может быть упорядочено. Эта функция полезна, когда вы хотите отсортировать срез по определённому атрибуту каждого элемента. В листинге 13-7 у нас есть список экземпляров `Rectangle`, и мы используем `sort_by_key`, чтобы упорядочить их по атрибуту `width` от меньшего к большему:

<span class="filename">Файл : src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-07/src/main.rs}}
```

<span class="caption">Листинг 13-7: Использование <code>sort_by_key</code> для сортировки прямоугольников по ширине</span>

Этот код печатает:

```console
{{#include ../listings/ch13-functional-features/listing-13-07/output.txt}}
```

Причина, по которой `sort_by_key` определена как принимающая замыкание `FnMut`, заключается в том, что она вызывает замыкание несколько раз: по одному разу для каждого элемента в срезе. Замыкание `|r| r.width` не захватывает, не изменяет и не перемещает ничего из своего окружения, поэтому оно удовлетворяет требованиям связанности признаков.

И наоборот, в листинге 13-8 показан пример замыкания, которое реализует только признак `FnOnce`, потому что оно перемещает значение из среды. Компилятор не позволит нам использовать это замыкание с `sort_by_key`:

<span class="filename">Файл : src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-08/src/main.rs}}
```

<span class="caption">Листинг 13-8: Попытка использовать замыкание <code>FnOnce</code> с <code>sort_by_key</code></span>

Это надуманный, запутанный способ (который не работает) попытаться подсчитать количество вызовов `sort_by_key` при сортировке `list`. Этот код пытается выполнить подсчёт, перемещая `value` - `String` из окружения замыкания - в вектор `sort_operations`. Замыкание захватывает `value`, затем перемещает `value` из замыкания, передавая право собственности на `value` вектору `sort_operations`. Это замыкание можно вызвать один раз; попытка вызвать его второй раз не сработает, потому что `value` уже не будет находиться в той среде, из которой его можно будет снова поместить в `sort_operations`! Поэтому это замыкание реализует только `FnOnce`. Когда мы пытаемся скомпилировать этот код, мы получаем ошибку, что `value` не может быть перемещено из замыкания, потому что замыкание должно реализовать `FnMut`:

```console
{{#include ../listings/ch13-functional-features/listing-13-08/output.txt}}
```

Ошибка указывает на строку в теле замыкания, которая перемещает `value` из окружения. Чтобы исправить это, нужно изменить тело замыкания так, чтобы оно не перемещало значения из окружения. Для подсчёта количества вызовов `sort_by_key` более простым способом является хранение счётчика в окружении и увеличение его значения в теле закрытия. Замыкание в листинге 13-9 работает с `sort_by_key`, поскольку оно фиксирует только изменяемую ссылку на счётчик `num_sort_operations` и поэтому может быть вызвано более одного раза:

<span class="filename">Файл : src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch13-functional-features/listing-13-09/src/main.rs}}
```

<span class="caption">Листинг 13-9: Использование замыкания <code>FnMut</code> с <code>sort_by_key</code> разрешено</span>

Трейты `Fn` важны при определении или использовании функций или типов, использующих замыкания. В следующем разделе мы обсудим итераторы. Многие методы итераторов принимают аргументы замыкания, поэтому не забывайте об этих деталях замыкания, по мере того как мы продвигаемся дальше!


