## Сохранение списка значений с помощью вектора

Первым типом коллекции, который мы разберём будет <code>Vec<T></code> известный как <em>вектор</em> (vector). Векторы позволяют сохранять множество данных в одной структуре, сохраняя элементы в памяти один за другим. Векторы могут сохранять данные только одного типа. Они удобны, когда нужно иметь список элементов, такие как текстовые строки в файле или цены в списке корзины покупок

### Создание нового вектора

Для создания нового вектора используется функция `Vec::new`, как показано в листинге 8-1.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-01/src/main.rs:here}}
```

<span class="caption">Листинг 8-1. Создание нового пустого вектора для хранения значений типа <code>i32</code></span>

Обратите внимание, что здесь мы добавили аннотацию типа. Поскольку мы не вставляем никаких значений в этот вектор, Rust не знает, какие элементы мы собираемся хранить. Это важный момент. Векторы реализованы с использованием обобщённых типов; мы рассмотрим, как использовать обобщённые типы с вашими собственными типами в главе 10. А пока знайте, что тип `Vec<T>` предоставляемый стандартной библиотекой, может содержать любой тип, и когда конкретный вектор содержит определённый тип, тип указаны в угловых скобках. В листинге 8-1 мы сообщили Rust, что `Vec<T>` в `v` будет содержать элементы типа `i32`.

В более реальном коде, Rust часто может вывести тип нужного для хранения значения, как только вы вставите значения. Так что вам довольно редко нужна данная аннотация типа. Более общим является создание `Vec<T>` имеющего начальные значения и Rust предоставляет макрос `vec!` для удобства. Макрос создаст новый вектор, содержащий указанные значения. Листинг 8-2 создает новый `Vec<i32>`, содержащий значения `1`, `2` и `3`. Числовым типом является `i32`, потому что это числовой тип по умолчанию, как обсуждалось в разделе [“Типы данных”](ch03-02-data-types.html#data-types)<!-- ignore --> главы 3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-02/src/main.rs:here}}
```

<span class="caption">Листинг 8-2. Создание нового вектора, содержащего значения</span>

Поскольку мы указали начальные значения <code>i32</code>, Rust может сделать вывод, что тип переменной <code>v</code> это <code>Vec<i32></code> и аннотация типа здесь не нужна. Далее мы посмотрим как изменять вектор.

### Изменение вектора

Чтобы создать вектор и затем добавить к нему элементы, можно использовать метод `push` показанный в листинге 8-3.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-03/src/main.rs:here}}
```

<span class="caption">Листинг 8-3. Использование метода <code>push</code> для добавления значений в вектор</span>

Как и с любой переменной, если мы хотим изменить её значение, нам нужно сделайте её изменяемой с помощью ключевого слова `mut`, как мы обсудили в главе 3. Числа мы помещаем в вектор типа `i32` и Rust выводит это из данных, так что аннотация `Vec<i32>` здесь не нужна.

### Удаление элементов из вектора

Подобно любой другой структуре `struct`, вектор освобождается, когда он выходит из области видимости, как прокомментировано в листинге 8-4.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-04/src/main.rs:here}}
```

<span class="caption">Листинг 8-4. Показывает, где вектор и его элементы удалены.</span>

When the vector gets dropped, all of its contents are also dropped, meaning those integers it holds will be cleaned up. This may seem like a straightforward point but can get a bit more complicated when you start to introduce references to the elements of the vector. Let’s tackle that next!

### Чтение данных вектора

Now that you know how to create, update, and destroy vectors, knowing how to read their contents is a good next step. There are two ways to reference a value stored in a vector. In the examples, we’ve annotated the types of the values that are returned from these functions for extra clarity.

В листинге 8-5 показаны оба метода доступа к значению в векторе либо с помощью синтаксиса индексации, либо с помощью метода `get`.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-05/src/main.rs:here}}
```

<span class="caption">Листинг 8-5. Использование синтаксиса индексации или метода <code>get</code> для доступа к элементу в векторе</span>

Обратите внимание здесь на пару деталей. Во-первых, используется значение индекса `2` для получения третьего элемента: векторы индексируются по номеру начиная с нуля. Во-вторых, два способа получения третьего элемента используя `&` и `[]` возвращающих ссылку или с помощью метода `get` с индексом, переданным в качестве аргумента, который возвращает `Option<&T>`.

В Rust есть два способа ссылаться на элемент, поэтому вы можете выбрать, как будет вести себя программа, когда вы попытаетесь использовать значение индекса, для которого в векторе нет элемента. В качестве примера давайте посмотрим, что будет делать программа, если у неё есть вектор, содержащий пять элементов, а затем он пытается получить доступ к элементу с индексом 100, как показано в листинге 8-6.

```rust,should_panic,panics
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-06/src/main.rs:here}}
```

<span class="caption">Листинг 8-6. Попытка доступа к элементу вектора по индексу 100, содержащему всего пять элементов</span>

Когда мы запускаем этот код, метод first `[]` вызовет панику программы, потому что он ссылается на несуществующий элемент. Этот метод лучше всего использовать, когда вы хотите, чтобы ваша программа аварийно завершила работу при попытке доступа к элементу за концом вектора.

Когда методу `get` передаётся индекс, который находится за пределами вектора, он без паники возвращает `None`. Вы могли бы использовать этот метод, если доступ к элементу за пределами диапазона вектора происходит время от времени при нормальных обстоятельствах. Тогда ваш код будет иметь логику для обработки наличия `Some(&element)` или `None`, как обсуждалось в главе 6. Например, индекс может исходить от человека, вводящего число. Если они случайно введут слишком большое число, и программа получит значение `None`, вы можете сообщить пользователю, сколько элементов находится в текущем векторе, и дать ему ещё один шанс ввести допустимое значение. Это было бы удобнее, чем сбой программы из-за опечатки!

Когда у программы есть действительная ссылка, средство проверки заимствований применяет правила владения и заимствования (описанные в главе 4), чтобы гарантировать, что эта ссылка и любые другие ссылки на содержимое вектора остаются действительными. Вспомните правило, которое гласит, что у вас не может быть изменяемых и неизменяемых ссылок в одной и той же области. Это правило применяется в листинге 8-7, где мы храним неизменяемую ссылку на первый элемент вектора и пытаемся добавить элемент в конец, что не сработает, если мы также попытаемся сослаться на этот элемент позже в функции:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-07/src/main.rs:here}}
```

<span class="caption">Листинг 8-7. Попытка добавить некоторый элемент в вектор, удерживая ссылку на элемент</span>

Компиляция этого кода приведёт к ошибке:

```console
{{#include ../listings/ch08-common-collections/listing-08-07/output.txt}}
```

Код в Листинге 8-7 возможно выглядит так, как будто он должен бы работать. Почему ссылка на первый элемент должна беспокоится про изменения в конце вектора? Это ошибка связана с тем, как работают векторы. Добавление нового элемента в конец вектора, может потребовать выделение нового участка памяти и копирования старых элементов в него, если было недостаточно места для размещения всех элементов рядом друг с другом, там где вектор находится в настоящее время. В этом случае ссылка на первый элемент будет указывать на освобождённую память. Правила заимствования нед опускают, чтобы программа оказалась в такой ситуации.

> Примечание: Дополнительные сведения о реализации типа `Vec<T>` смотрите в разделе [“The Rustonomicon”](https://doc.rust-lang.org/nomicon/vec.html).

### Перебор значений в векторе

Если мы хотим получить доступ к каждому элементу вектора по очереди, мы можем перебирать все элементы, а не использовать индексы для доступа по одному за раз. В листинге 8-8 показано, как использовать цикл `for` для получения неизменяемых ссылок на каждый элемент в векторе значений `i32` и их печати.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-08/src/main.rs:here}}
```

<span class="caption">Листинг 8-8. Печать каждого элемента в векторе, перебирая элементы с помощью цикла <code>for</code></span>

Мы также можем перебирать изменяемые ссылки на каждый элемент изменяемого вектора, чтобы вносить изменения во все элементы. Цикл `for` в листинге 8-9 добавит `50` к каждому элементу.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-09/src/main.rs:here}}
```

<span class="caption">Листинг 8-9. Итерация по изменяемым ссылкам на<br>элементы в векторе</span>

Чтобы изменить значение на которое ссылается изменяемая ссылка, мы должны использовать оператор разыменования (`*`) для получения значение в переменную `i` прежде чем использовать оператор `+=`. Мы поговорим подробнее об операторе разыменования в разделе [«Следуя указателю на значение с помощью оператора разыменования»](../std/vec/struct.Vec.html) главы 15.

### Использование перечисления для хранения множества разных типов

В начале этой главы мы говорили, что векторы могут хранить только значения одинакового типа. Это может быть неудобно; безусловно есть случаи, когда необходим список из элементов разного типа. К счастью, варианты перечисления определены в самом типе перечисления, поэтому когда нам нужно хранить в векторе элементы различного типа, можно определить и использовать перечисление!

Например, мы хотим получить значения из строки в электронной таблице где некоторые столбцы строки содержат целые числа, некоторые числа с плавающей точкой или строковые значения. Можно определить перечисление, варианты которого будут содержать разные типы значений и тогда все варианты перечисления будут считаться одними и тем же типом: самим перечислением. Затем можно создать вектор, который содержит это перечисление и таким образом в конечном счёте содержит разные типы. Мы продемонстрировали это в листинге 8-10.

```rust
{{#rustdoc_include ../listings/ch08-common-collections/listing-08-10/src/main.rs:here}}
```

<span class="caption">Листинг 8-10. Определение <code>enum</code> для хранения значений разных типов в векторе</span>

Rust должен знать, какие типы будут в векторе во время компиляции, чтобы знать сколько именно памяти в куче потребуется для хранения каждого элемента. Вторичным преимуществом является то, что мы можем чётко указать какие типы разрешены в таком векторе. Если бы Rust позволял вектору содержать любой тип, был бы шанс что один или несколько типов будут вызывать ошибки при выполнении операций над элементами вектора. Используя перечисление вместе с выражением `match` означает, что во время компиляции Rust гарантирует  обработку каждого возможного случая, как обсуждалось в главе 6.

При написании программы, если вы не знаете исчерпывающий набор типов программы во время выполнения для сохранения их в вектор,  то техника использования перечисления не будет работать. Вместо этого вы можете использовать объект типажа, который мы рассмотрим в главе 17.

Теперь, когда мы обсудили некоторые из наиболее распространённых способов использования векторов, просмотрите документацию по API для всего множества полезных методов, определённых в `Vec<T>` из стандартной библиотеки. Например, в дополнение к методам `push`, `pop` есть метод удаления и возвращения последнего элемента. Давайте перейдём к следующему типу коллекций: строки `String`!
