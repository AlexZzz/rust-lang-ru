## Выразительное управление с помощью `if let`

Синтаксис `if let` позволяет комбинировать `if` и `let` в менее многословный способ обработки значений, соответствующих одному шаблону, одновременно игнорируя все остальные. Рассмотрим программу в листинге 6-6, которая делает поиск по шаблону значения `Option<u8>`, но хочет выполнить код только когда значение равно 3.

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

<span class="caption">Листинг 6-6. Выражение <code>match</code> заботится только о выполнении кода при значении равном <code>Some(3)</code></span>

Мы хотим выполнить что-нибудь при совпадении `Some(3)` и ничего не делать с любым другим `Some<u8>` или значением `None` . Для удовлетворения `match` выражения необходимо добавить `_ => ()` после обработки только одного варианта, который экономит добавление массы стандартного кода.

Вместо этого мы могли бы написать это более коротким способом, используя `if let`. Следующий код ведёт себя так же, как выражение `match` в листинге 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

Синтаксис `if let` принимает шаблон и выражение, разделённые знаком равенства. Он работает так же, как `match`, где выражение сравнивается с образцом в `match` и шаблоном является первый рукав.

Использование `if let` означает меньше кода, меньше отступов и меньше стандартного кода. Тем не менее, вы теряете полную проверку, предоставляемую выражением `match`. Выбор между `match` и `if let` зависит от того, что вы делаете в вашем конкретном случае и является ли получение краткости подходящим компромиссом при потере полноты проверки.

Другими словами, можно думать о `if let` как о синтаксическом сахаре для выражения `match`, которое выполняет код, когда значение соответствует одному шаблону и затем игнорирует все остальные значения.

Можно включить `else` вместе с `if let`. Блок кода, который идёт с `else` является таким же как блок кода, который будет идти с `_` в случае выражения `match`, которое эквивалентно `if let` и `else`. Вспомним объявление перечисления `Coin` в листинге 6-4, где вариант `Quarter` также содержит внутри значение штата типа `UsState`. Если мы хотели бы посчитать все монеты не являющиеся четвертями одновременно печатая название штата из четвертины, то мы могли бы сделать это с помощью выражения `match` таким образом:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

Или мы могли бы использовать выражение `if let` и `else` так:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

Если у вас есть ситуация в которой ваша программа имеет слишком многословную логику, можно выразить её используя  `match`, помните, что `if let` также есть в вашем наборе инструментов Rust.

## Итоги

Мы рассмотрели как использовать перечисления для создания пользовательских типов, которые могут быть одним из наборов перечисляемых значений. Мы показали, как тип `Option<T>` из стандартной библиотеки помогает использовать систему типов для предотвращения ошибок. Когда значения перечисления имеют данные внутри них, можно использовать `match` или `if let`, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.

Теперь ваши программы Rust могут выражать концепции в предметной области используя структуры и перечисления. Создание пользовательских типов для использования в API обеспечивает безопасность типов: компилятор позаботится о том, чтобы функции получали значения только того типа, которые ожидает функция.

Чтобы предоставить хорошо организованный API пользователям, необходимо использовать и показывать только то, что нужно пользователям, давайте теперь обратимся к модулям в Rust.
