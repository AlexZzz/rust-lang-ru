## Компактное управление потоком выполнения с `if let`

Синтаксис `if let` позволяет скомбинировать `if` и `let` в менее многословную конструкцию, и затем обработать значения соответствующе только одному шаблону, одновременно игнорируя все остальные. Рассмотрим программу, в которой мы делаем поиск по шаблону значения `Option<u8>`, чтобы выполнить код только когда значение равно 3:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/listing-06-06/src/main.rs:here}}
```

<span class="caption">Листинг 6-6. Выражение <code>match</code> которое выполнит код только при значении равном <code>Some(3)</code></span>

Мы хотим выполнить что-нибудь при совпадении значения с `Some(3)` и не хотим ничего делать с любым другим `Some<u8>` или значением `None` . Для удовлетворения `match`, после первой и единственной ветки, нам пришлось добавить дополнительный шаблонный код: ветку `_ => ()`.

Вместо этого мы могли бы решить нашу задачу более коротким способом, используя `if let`. Следующий код ведёт себя так же, как выражение `match` в листинге 6-6:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-12-if-let/src/main.rs:here}}
```

Синтаксис `if let` принимает шаблон и выражение, разделённые знаком равенства. `if let` сработает так же, как `match`, когда в него на вход передадут выражение и подходящим шаблоном для этого выражения окажется первая ветка.

Используя `if let` мы меньше печатаем, меньше делаем отступов и меньше получаем шаблонного кода. Тем не менее, мы теряем полную проверку всех вариантов, предоставляемую выражением `match`. Выбор между `match` и `if let` зависит от того, что вы делаете в вашем конкретном случае и является ли получение краткости при потере полноты проверки подходящим компромиссом.

Другими словами, вы можете думать о конструкции `if let` как о <em>синтаксическом сахаре</em> для `match`, который выполнит код `match` только тогда, когда входное значение будет соответствовать единственному шаблону конструкции, а затем проигнорирует все остальные значения.

Можно добавлять `else` к `if let`. Блок кода, который находится внутри `else` аналогичен по смыслу блоку кода ветки связанной с шаблоном `_` выражения `match` (которое эквивалентно сборной конструкции `if let` и `else`). Вспомним объявление перечисления `Coin` в листинге 6-4, где вариант `Quarter` также содержит внутри значение штата типа `UsState`. Если бы мы хотели посчитать все монеты не являющиеся четвертями, а для четвертей печатать название штата, то мы могли бы сделать это с помощью выражения `match` таким образом:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-13-count-and-announce-match/src/main.rs:here}}
```

Или мы могли бы использовать выражение `if let` и `else` так:

```rust
{{#rustdoc_include ../listings/ch06-enums-and-pattern-matching/no-listing-14-count-and-announce-if-let-else/src/main.rs:here}}
```

Если у вас есть ситуация в которой ваша программа имеет логику которая слишком многословна для того чтобы её выражать используя `match`, помните, о том, что также в вашем наборе инструментов Rust есть `if let`.

## Итоги

Мы рассмотрели как использовать перечисления для создания пользовательских типов, которые могут быть одним из наборов перечисляемых значений. Мы показали, как тип `Option<T>` из стандартной библиотеки помогает использовать систему типов для предотвращения ошибок. А когда значения перечисления имеют данные внутри них, можно использовать `match` или `if let`, чтобы извлечь и пользоваться значением, в зависимости от того, сколько случаев нужно обработать.

Теперь ваши программы Rust могут выражать концепции вашей предметной области используя структуры и перечисления. Создание и использование пользовательских типов в API обеспечивает типобезопасность (type safety) вашего API: компилятор позаботится о том, чтобы функции получали значения только того типа, который они ожидают.

Чтобы предоставить хорошо организованный API пользователям, необходимо использовать и показывать только то, что нужно пользователям, давайте теперь обратимся к модулям в Rust.
