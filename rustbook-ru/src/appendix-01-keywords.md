## Приложение A: Ключевые слова

Следующий список содержит ключевые слова, зарезервированные для текущего или будущего использования в языке Rust. Как таковые их нельзя использовать в качестве идентификаторов (за исключением сырых идентификаторов, которые мы обсудим в разделе [«Сырые идентификаторы»]<!-- ignore -->). Идентификаторы — это имена функций, переменных, параметров, полей структур, модулей, крейтов, констант, макросов, статических значений, атрибутов, типов, свойств или времён жизни.

### Используемые в настоящее время ключевые слова

Ниже приведён список используемых в настоящее время ключевых слов с описанием их функций.

- `as` — выполнить примитивное преобразование, уточнить конкретную характеристику, которую содержит объект, или переименовать элемент в выражении <code>use</code>
- <code>async</code> —  вернуть <code>Future</code> вместо блокирования текущего потока
- <code>await</code> — немедленно завершить цикл приостановить выполнение до тех пор, пока не будет готов результат <code>Future</code>
- <code>break</code> — немедленно завершить цикл
- <code>const</code> — определить константу или неизменяемый указатель
- <code>continue</code> — досрочно перейти к следующей итерации цикла
- <code>crate</code> — в пути модуля ссылается на корень пакета
- <code>dyn</code> — динамическая отсылка к объекту характеристики
- <code>else</code> — ветвь для конструкций потока управления <code>if</code> и <code>if let</code> в случае, если никакая другая ветвь не была исполнена
- <code>enum</code> — определить перечисление
- <code>extern</code> — подключить внешнюю функцию или переменную
- <code>false</code> — логический литерал «ложь»
- <code>fn</code> — определить функцию или тип указателя на функцию
- <code>for</code> — перебор элементов итератора, реализация типажа или указание срока жизни более продолжительного периода
- <code>if</code> — ветвление на основе результата условного выражения
- <code>impl</code> — реализовать функциональность непосредственно или через типаж
- <code>in</code> — часть синтаксиса определения цикла  <code>for</code>
- <code>let</code> — объявить переменную
- <code>loop</code> — безусловный (бесконечный) цикл
- <code>match</code> — сопоставить значение с образцами
- <code>mod</code> — определить модуль
- <code>move</code> — заставить замыкание принять на себя владение всеми своими захватами
- <code>mut</code> — обозначить изменяемость для ссылок, сырых указателей или привязок к шаблонам
- <code>pub</code> — обозначить публичную доступность полей структур, блоков <code>impl</code> или модулей
- <code>ref</code> — привязка по ссылке
- <code>return</code> — возврат из функции
- <code>Self</code> — псевдоним для типа, который мы определяем или реализуем
- <code>self</code> — объект, содержащий этот метод, или текущий модуль
- <code>static</code> — глобальная переменная или время жизни на протяжении всего выполнения программы
- <code>struct</code> — определить структуру
- <code>super</code> — родительский модуль текущего модуля
- <code>trait</code> — определить типаж
- <code>true</code> — логический литерал «истина»
- <code>type</code> — определить псевдоним типа или ассоциированный тип
- `union` - определить [union]<!-- ignore -->; является только ключевым словом при использовании в объявлении объединения
- <code>unsafe</code> — обозначить небезопасный код, функции, типажа или реализации
- <code>use</code> — ввести объекты в область видимости
- <code>where</code> — обозначить утверждения, которые ограничивают тип
- <code>while</code> — цикл, работающий относительно результата условного выражения

### Ключевые слова, зарезервированные для будущего использования

Следующие ключевые слова ещё не имеют никакой функциональности, но зарезервированы Rust для возможного использования в будущем.

- `abstract`
- `become`
- `box`
- `do`
- `final`
- `macro`
- `override`
- `priv`
- `try`
- `typeof`
- `unsized`
- `virtual`
- `yield`

### Сырые идентификаторы<a id="raw-identifiers"></a>

*Сырые идентификаторы* — это синтаксис, позволяющий использовать ключевые слова там, где обычно они не могут быть. Для создания и использования сырого идентификатора к ключевому слову добавляется префикс `r#`.

Например, ключевое слово `match`. Если вы попытаетесь скомпилировать следующую функцию, использующую в качестве имени `match`:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
fn match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}
```

вы получите ошибку:

```text
error: expected identifier, found keyword `match`
 --> src/main.rs:4:4
  |
4 | fn match(needle: &str, haystack: &str) -> bool {
  |    ^^^^^ expected identifier, found keyword
```

Ошибка говорит о том, что вы не можете использовать ключевое слово `match` в качестве идентификатора функции. Чтобы получить возможность использования слова `match` в качестве имени функции, нужно использовать синтаксис «сырых идентификаторов», например так:

<span class="filename">Файл: src/main.rs</span>

```rust
fn r#match(needle: &str, haystack: &str) -> bool {
    haystack.contains(needle)
}

fn main() {
    assert!(r#match("foo", "foobar"));
}
```

Этот код скомпилируется без ошибок. Обратите внимание, что префикс `r#` в определении имени функции указан так же, как он указан в месте её вызова в `main`.

Сырые идентификаторы позволяют вам использовать любое слово, которое вы выберете, в качестве идентификатора, даже если это слово окажется зарезервированным ключевым словом. Это даёт нам больше свободы в выборе имён идентификаторов, а также позволяет нам интегрироваться с программами, написанными на языке, где эти слова не являются ключевыми. Кроме того, необработанные идентификаторы позволяют вам использовать библиотеки, написанные в версии Rust, отличной от используемой в вашем крейте. Например, `try` не является ключевым словом в выпуске 2015 года, но есть в выпуске 2018 года. Если вы зависите от библиотеки, написанной с использованием версии 2015 года и имеющей функцию `try`, вам потребуется использовать синтаксис сырого идентификатора, в данном случае `r#try`, для вызова этой функции из кода версии 2018 года. См. [Приложение E]<!-- ignore --> для получения дополнительной информации о редакциях Rust.


[«Сырые идентификаторы»]: #raw-identifiers
[union]: ../reference/items/unions.html
[Приложение E]: appendix-05-editions.html