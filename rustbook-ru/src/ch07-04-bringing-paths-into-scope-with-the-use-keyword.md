## Подключение путей в область видимости с помощью ключевого слова `use`

Может показаться, что пути, которые мы писали для вызова функций неудобные, длинные и повторяющиеся. Например, в листинге 7-7, где мы выбирали абсолютный или относительный путь к функции `add_to_waitlist`, каждый раз для вызова `add_to_waitlist` мы должны были указать модули `front_of_house` и `hosting`. К счастью, есть способ упрощения этого процесса. Можно подключить путь в область видимости один раз, а затем вызывать элементы из этого пути будто это локальные элементы используя ключевое слово `use`.

В листинге 7-11 мы подключили модуль `crate::front_of_house::hosting` в область действия функции `eat_at_restaurant`, поэтому нам достаточно только указать `hosting::add_to_waitlist` для вызова функции `add_to_waitlist` внутри `eat_at_restaurant`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-11/src/lib.rs}}
```

<span class="caption">Листинг 7-11. Подключение модуля в область видимости с помощью <code>use</code></span>

Добавление `use` и пути в область видимости аналогично созданию символической ссылки в файловой системе. Добавляя `use crate::front_of_house::hosting` в корень крейта, `hosting` теперь является допустимым именем в этой области, как если бы `hosting` модуль был определён в корне крейта. Пути подключённые в область видимости с помощью `use` также проверяют конфиденциальность как и любые другие пути.

Также можно подключить элемент в область видимости с помощью `use` и относительного пути. Листинг 7-12 показывает как указать относительный путь, чтобы получить то же поведение, что и в листинге 7-11.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-12/src/lib.rs}}
```

<span class="caption"><span class="caption">Листинг 7-12. Подключение модуля в область видимости с помощью <code>use</code></span> и относительного пути</span>

### Создание идиоматических путей с `use`

В листинге 7-11 вы могли бы задаться вопросом, почему мы указали  `use crate::front_of_house::hosting`, а затем вызвали `hosting::add_to_waitlist` внутри `eat_at_restaurant` вместо указания в  `use` полного пути прямо до функции `add_to_waitlist` для получения того же результата, что в листинге 7-13.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-13/src/lib.rs}}
```

<span class="caption">Листинг 7-13. Подключение функции <code>add_to_waitlist</code>  в область видимости с помощью <code>use</code> <em>не идиоматическим</em> способом</span>

Хотя листинги 7-11 и 7-13 выполняют одну и ту же задачу, листинг 7-11 является идиоматическим способом подключения функции в область видимости с помощью `use`. Подключение родительского модуля функции в область видимости при помощи `use`, и последующее указание родительского модуля в строке вызова его функций, даёт ясное понимание того, что эта функция определена не локально, и в то же время всё ещё минимизирует повторение полного пути. В коде листинга 7-13 не ясно, где именно определена `add_to_waitlist`.

С другой стороны, при подключении структур, перечислений и других элементов используя `use`, идиоматически правильным будет указывать полный путь. Листинг 7-14 показывает идиоматический способ подключения структуры стандартной библиотеки `HashMap` в область видимости исполняемого крейта.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-14/src/main.rs}}
```

<span class="caption">Листинг 7-14. Подключение <code>HashMap</code> в область видимости идиоматическим способом</span>

За этой идиомой нет веской причины: это просто соглашение, которое появилось само собой. Люди привыкли читать и писать код Rust таким образом.

Исключением из этой идиомы является случай, когда мы подключаем два элемента с одинаковыми именами в область видимости используя оператор `use` - Rust просто не позволяет этого сделать. Листинг 7-15 показывает, как подключить в область действия два типа с одинаковыми именами `Result`, но из разных родительских модулей и как на них ссылаться.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-15/src/lib.rs:here}}
```

<span class="caption">Листинг 7-15. Подключение двух типов с одинаковыми именами в одну область видимости требует использования их родительских модулей.</span>

Как видите, использование имени родительских модулей позволяет различать два типа `Result`. Если бы вместо этого мы указали `use std::fmt::Result` и `use std::io::Result`, мы бы имели два типа `Result` в одной области видимости, и Rust не смог бы понять какой из двух `Result` мы имели в виду когда нашёл бы их употребление в коде.

### Предоставление новых имён с помощью ключевого слова `as`

Есть ещё одно решение проблемы объединения двух типов с одинаковыми именами в одной области видимости используя `use`: после пути можно указать `as` и новое локальное имя (псевдоним) для типа. Листинг 7-16 показывает другой способ написать код в листинге 7-15 путём переименования одного из двух типов `Result` используя `as`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-16/src/lib.rs:here}}
```

<span class="caption">Листинг 7-16. Переименование типа с помощью ключевого слова <code>as</code> при его подключении в область видимости</span>

Во втором операторе `use` мы выбрали новое имя `IoResult` для типа `std::io::Result`, которое теперь не будет конфликтовать с типом `Result` из `std::fmt`, который также подключён в область видимости. Листинги 7-15 и 7-16 считаются идиоматичными, поэтому выбор за вами!

### Реэкспорт имён с `pub use`

Когда мы подключаем имя в область видимости используя ключевое слово `use`, то имя доступное в новой области видимости является приватным. Чтобы позволить коду, который вызывает наш код, ссылаться на это имя, как если бы оно было определено в области видимости данного кода, можно объединить `pub` и `use`. Этот метод называется *реэкспортом (re-exporting)*, потому что мы подключаем элемент в область видимости, но также делаем этот элемент доступным для подключения в других областях видимости.

Листинг 7-17 показывает код как в листинге 7-11 (где используется `use` в корневом модуле), но с изменениями: теперь применяется `pub use`.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground,test_harness
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-17/src/lib.rs}}
```

<span class="caption">Листинг 7-17. Делаем при помощи <code>pub use</code> имя доступным для любого кода из новой области видимости</span>

Благодаря использованию `pub use`, внешний код теперь может вызывать функцию `add_to_waitlist` используя `hosting::add_to_waitlist`. Если бы мы не указали `pub use`, то только функция `eat_at_restaurant` могла бы вызывать `hosting::add_to_waitlist` в своей области видимости, но внешний код не смог бы так сделать.

Реэкспорт полезен, когда внутренняя структура вашего кода отличается от того, как другие программисты вызывающие ваш код, будут думать о предметной области. Например, в метафоре про ресторан, люди работающие в ресторане, думают о «фронтальной части дома» и «задней части дома». Но вероятно что клиенты посещающие ресторан, не буду думать о частях ресторана в таких терминах. С помощью `pub use`, можно структурировать код по одному принципу, но наружу публиковать другие варианты структуризации кода (подходящие под разные предметные области). Благодаря этому мы можем сделать нашу библиотеку удобно организованной как для программистов, работающих над библиотекой так и для программистов вызывающих нашу библиотеку.

### Использование внешних пакетов

В Главе 2 мы запрограммировали игру угадывания числа, где использовался внешний пакет для получения случайного числа, называемый `rand`. Чтобы использовать в нашем проекте пакет `rand`, мы добавили строку в *Cargo.toml*:

<!-- When updating the version of `rand` used, also update the version of
`rand` used in these files so they all match:
* ch02-00-guessing-game-tutorial.md
* ch14-03-cargo-workspaces.md
-->

<span class="filename">Файл: Cargo.toml</span>

```toml
{{#include ../listings/ch02-guessing-game-tutorial/listing-02-02/Cargo.toml:9:}}
```

Добавление `rand` в качестве зависимости в *Cargo.toml* указывает Cargo загрузить пакет `rand` и любые требующиеся для работы этого пакета зависимости из [crates.io](https://crates.io/) и сделать `rand` доступным для нашего проекта.

Затем, чтобы подключить определения `rand` в область видимости нашего пакета, мы добавили строку `use` начинающуюся с названия пакета `rand` и списка элементов, которые мы хотим подключить в область видимости. Напомним, что в разделе ["Генерация случайного числа"]<!-- ignore --> Главы 2, мы подключили типаж `Rng` в область видимости и вызвали функцию `rand::thread_rng`:

```rust,ignore
{{#rustdoc_include ../listings/ch02-guessing-game-tutorial/listing-02-03/src/main.rs:ch07-04}}
```

Члены сообщества Rust сделали много пакетов доступными на ресурсе [crates.io](https://crates.io/), и добавление любого из них в свой пакет включает в себя одни и те же шаги: добавить пакет в файл *Cargo.toml* вашего пакета, использовать `use` для подключения элементов этого пакета в область видимости.

Обратите внимание, стандартная библиотека (`std`) также является крейтом, который является внешним по отношению к нашему пакету. Поскольку стандартная библиотека поставляется с языком Rust, то не нужно вносить изменения в *Cargo.toml* для подключения `std`. Но чтобы добавить её элементы в область видимости нашего пакета, нам нужно сослаться на неё используя `use`. Например, чтобы добавить `HashMap` в область видимости нам потребуется использовать следующую строку:

```rust
use std::collections::HashMap;
```

Это абсолютный путь, начинающийся с `std`, имени крейта стандартной библиотеки.

### Использование вложенных путей для уменьшения длинных списков `use`

Если мы используем несколько элементов определённых в одном пакете или в том же модуле, то перечисление каждого элемента в отдельной строке может занимать много вертикального пространства в файле. Например, эти два объявления `use` используются в программе угадывания числа (листинг 2-4) для подключения элементов из `std` в область видимости:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/no-listing-01-use-std-unnested/src/main.rs:here}}
```

Вместо этого, для того чтобы подключить в область видимости те же элементы одной строкой, можно использовать вложенные пути. Мы делаем это, как показано в листинге 7-18, указывая общую часть пути, за которой следуют два двоеточия, а затем фигурные скобки вокруг списка тех частей продолжения пути, которые отличаются.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-18/src/main.rs:here}}
```

<span class="caption">Листинг 7-18. Указание вложенных путей для подключения в область видимости нескольких элементов с одинаковым префиксом</span>

В больших программах, подключение множества элементов из одного пакета или модуля с использованием вложенных путей может уменьшить количество отдельных строк с `use`, в тех случаях когда подключаемых элементов много.

Можно использовать вложенный путь на любом уровне, что полезно при объединении двух операторов `use`, которые имеют общую часть пути. Например, в листинге 7-19 показаны два оператора `use`: один подключает  `std::io`, другой подключает `std::io::Write` в область видимости.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-19/src/lib.rs}}
```

<span class="caption">Листинг 7-19. Два оператора <code>use</code> где один содержит часть пути другого</span>

Общей частью этих двух путей является `std::io`, и это полный первый путь. Чтобы объединить эти два пути в одно выражение `use`, мы можем использовать ключевое слово `self` во вложенном пути, как показано в листинге 7-20.

<span class="filename">Файл: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-20/src/lib.rs}}
```

<span class="caption">Листинг 7-20. Объединение путей из листинга 7-19 в один оператор <code>use</code></span>

Эта строка подключает `std::io` и `std::io::Write` в область видимости.

### Оператор * (Glob)

Если хотим подключить в область видимости *все* общие элементы, определённые в пути, можно указать путь за которым следует оператор `*` *(звёздочка, glob)*:

```rust
use std::collections::*;
```

Этот оператор `use` подключает все открытые элементы из модуля `std::collections` в текущую область видимости. Будьте осторожны при использовании оператора <code>*</code>! Он может усложнить понимание, какие имена находятся в области видимости и где были определены имена, используемые в вашей программе.

Оператор `*` часто используется при тестировании для подключения всего что есть в модуле `tests`; мы поговорим об этом в разделе ["Как писать тесты"]<!--  --> Главы 11. Оператор `*` также иногда используется как часть шаблона *автоматического импорта (prelude)*: смотрите [документацию по стандартной библиотеке](../std/prelude/index.html#other-preludes)<!-- ignore --> для получения дополнительной информации об этом шаблоне.


["Генерация случайного числа"]: ch02-00-guessing-game-tutorial.html#generating-a-random-number
["Как писать тесты"]: ch11-01-writing-tests.html#how-to-write-tests