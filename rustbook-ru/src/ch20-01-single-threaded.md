## Создание однопоточного веб-сервера

Начнём с получения рабочего однопоточного веб-сервера. Прежде чем мы начнём, давайте посмотрим на краткий обзор протоколов, участвующих в создании веб серверов. Детали этих протоколов выходят за рамки этой книги, но краткий обзор предоставит вам необходимую информацию.

Двумя основными протоколами, используемыми в веб-серверах, являются *протокол передачи гипертекста* *(HTTP - Hypertext Transfer Protocol)* и *Протокол управления передачей* *(TCP - Transmission Control Protocol)*. Оба протокола являются протоколами типа *запрос-ответ* (request-response), то есть *клиент* инициирует запросы, а *сервер* слушает запросы и предоставляет ответ клиенту. Содержимое этих запросов и ответов определяется протоколами.

TCP - это протокол нижнего уровня, который описывает детали того, как информация передается от одного сервера к другому, но не определяет, что это за информация. HTTP строится поверх TCP, определяя содержимое запросов и ответов. Технически возможно использовать HTTP с другими протоколами, но в подавляющем большинстве случаев HTTP отправляет свои данные поверх TCP. Мы будем работать с необработанными байтами в TCP и запросами и ответами в HTTP.

### Прослушивание TCP соединения

Нашему веб-серверу необходимо прослушивать TCP-соединение, так что это первая часть, над которой мы будем работать. Стандартная библиотека предлагает для этого модуль `std::net`. Сделаем новый проект обычным способом:

```console
$ cargo new hello
      Created binary (application) `hello` project
$ cd hello
```

Теперь введите код из листинга 20-1 в файл *src/main.rs* для начала. Этот код будет прослушивать входящие TCP потоки по адресу `127.0.0.1:7878`. Когда сервер принимает входящий поток, он напечатает `Connection established!`.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
{{#rustdoc_include ../listings/ch20-web-server/listing-20-01/src/main.rs}}
```

<span class="caption">Листинг 20-1. Прослушивание входящих соединений и печать сообщения в ответ.</span>

Используя `TcpListener`, можно прослушивать TCP соединения по адресу `127.0.0.1:7878`. В адресе, в его части перед двоеточием, сначала идёт IP-адрес представляя ваш компьютер (он одинаковый на каждом компьютере и не представляет конкретный компьютер автора), а часть `7878` является портом. Мы выбрали этот порт по двум причинам: HTTP обычно может принимает на этом порту, и 7878 - это слово *rust* набранное на телефоне.

Функция `bind` в этом сценарии работает как функция `new`, в том плане что она вернёт новый экземпляр `TcpListener`. Причина по которой функция называется `bind` заключается в том, что в сети подключение к порту для прослушивания известно как "привязка к порту", которую можно сделать только один раз из одной программы в системе, до тех пор пока порт не освобождён программой.

Функция `bind` возвращает `Result<T, E>` , который указывает, что привязка может завершиться ошибкой. Например, для подключения к порту 80 требуются права администратора (не администраторы могут прослушивать только порты выше 1024), поэтому, если мы попытаемся подключиться к порту 80, не будучи администратором, привязка не сработает. Другой пример: привязка не сработает, если мы запустили два экземпляра нашей программы, и поэтому две программы будут прослушивать один и тот же порт. Поскольку мы пишем базовый сервер только в учебных целях, мы не будем беспокоиться об обработке таких ошибок; вместо этого мы используем `unwrap` чтобы остановить программу в случае возникновения ошибок.

Метод `incoming` в `TcpListener` возвращает итератор, который дает нам последовательность потоков (конкретнее, потоков типа `TcpStream` ). Один *поток* представляет собой открытое соединение между клиентом и сервером. *Соединение* - это полный процесс запроса и ответа, в котором клиент подключается к серверу, сервер генерирует ответ, и сервер закрывает соединение. Таким образом, `TcpStream` позволяет прочитать из себя, то что отправил клиент, а затем позволяет записать наш ответ в поток. В целом, цикл `for` будет обрабатывать каждое соединение по очереди и создавать серию потоков, которые мы будем обрабатывать.

На данный момент наша обработка потока состоит из вызова `unwrap` для завершения нашей программы, если в потоке есть ошибки; если ошибок нет, программа выводит сообщение. Мы добавим больше функций для успешного случая в следующем листинге. Причина, по которой мы можем получать ошибки в методе `incoming`, когда клиент подключается к серверу, заключается в том, что мы на самом деле итерируем не подключение. Вместо этого мы итерируем *попытки подключения* . Подключение может быть неудачным по ряду причин, многие из которых зависят от операционной системы. Например, многие операционные системы имеют ограничение на количество одновременных открытых подключений, которые они могут поддерживать; новые попытки подключения сверх этого числа вызовут ошибку, пока некоторые из открытых подключений не будут закрыты.

Попробуем запустить этот код! Вызовите `cargo run` в терминале, а затем загрузите *127.0.0.1:7878* в веб-браузере. В браузере должно отображаться сообщение об ошибке, например «Connection reset», поскольку сервер в настоящее время не отправляет обратно никаких данных. Но когда вы посмотрите на свой терминал, вы должны увидеть несколько сообщений, которые были напечатаны, когда браузер подключался к серверу!

```text
     Running `target/debug/hello`
 Connection established!
 Connection established!
 Connection established!
```

Иногда вы будете видеть несколько сообщений, напечатанных для одного запроса браузера; Причина может заключаться в том, что браузер выполняет не только запрос страницы, а также других ресурсов, таких как иконка *favicon.ico,*, которая отображается на вкладке браузера.

Может случиться так, что браузер пытается подключиться к серверу несколько раз, потому что сервер не отправляет в ответ никаких данных. Когда экземпляр `stream` выходит из области видимости и он удаляется в конце цикла, соединение закрывается как часть реализации типажа `drop`. Браузеры иногда обрабатывают закрытое соединение с помощью повторных запросов, потому что это может быть временной проблемой. Важным фактором является то, что успешно удалось обработать TCP соединение!

Не забудьте остановить программу, нажав <span class="keystroke">ctrl-c,</span> когда вы закончите запускать определенную версию кода. Затем перезапустите `cargo run` после того, как вы внесли следующий набор изменений, чтобы убедиться, что вы используете самый новый код.

### Чтение запросов

Реализуем функционал чтения запроса из браузера! Чтобы разделить части, связанные с получением соединения и последующим действием с ним, мы запустим новую функцию для обработки соединения. В этой новой функции `handle_connection` мы будем читать данные из потока TCP и распечатывать их, чтобы мы могли видеть данные, отправленные из браузера. Измените код, чтобы он выглядел как в листинге 20-2.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
use std::io::prelude::*; use std::net::TcpStream; use std::net::TcpListener;  fn main() {     let listener = TcpListener::bind("127.0.0.1:7878").unwrap();      for stream in listener.incoming() {         let stream = stream.unwrap();          handle_connection(stream);     } }  fn handle_connection(mut stream: TcpStream) {     let mut buffer = [0; 512];      stream.read(&mut buffer).unwrap();      println!("Request: {}", String::from_utf8_lossy(&buffer[..])); }
```

<span class="caption">Листинг 20-2: Чтение из потока <code>TcpStream</code> и печать данных</span>

Мы добавили `std::io::prelude` в область видимости, чтобы получить доступ к типажам, которые позволяют читать и писать в поток. В цикле `for` функции `main` вместо того, чтобы печатать сообщение о том, что мы установили соединение, мы теперь вызываем новую функцию `handle_connection` и передаём ей `stream`.

В функции `handle_connection` мы сделали параметр `stream` изменяемым. Причина в том, что экземпляр `TcpStream` внутри отслеживает, какие данные он нам возвращает. Он может прочитать больше данных, чем мы просили и сохранить эти данные для следующего раза, когда мы просим данные. Поэтому он должен быть `mut` так как его внутреннее состояние может измениться; обычно мы думаем о "чтении" как об операции не нуждающейся в изменении данных, но в данном случае нам нужно ключевое слово `mut`.

Далее нам нужно фактически прочитать данные из потока. Мы делаем это в два этапа: во-первых, мы объявляем `buffer` в стеке для хранения считываемых данных. Мы сделали буфер размером 1024 байта, что достаточно для хранения данных базового запроса и достаточно для наших целей в этой главе. Если бы мы хотели обрабатывать запросы произвольного размера, управление буфером должно было бы быть более сложным; пока делаем проще. Мы передаем буфер в `stream.read` , который считывает байты из `TcpStream` и помещает их в буфер.

Во-вторых, мы конвертируем байты из буфера в строку и печатаем эту строку. Функция `String::from_utf8_lossy` принимает `&[u8]` и создаёт из неё `String`. Названия «lossy» (с потерями) в её имени указывает на поведение этой функции. Когда она видит недопустимую последовательность UTF-8: она заменяет недопустимую последовательность на символ `�`, символ замены `U+FFFD REPLACEMENT CHARACTER`. Вы могли видеть заменяющие символы в буфере, который не заполнен данными из запроса.

Попробуем этот код! Запустите программу и снова сделайте запрос в веб-браузере. Обратите внимание, что мы по-прежнему будем получать в браузере страницу с ошибкой, но вывод нашей программы в терминале теперь будет выглядеть примерно так:

```console
$ cargo run
   Compiling hello v0.1.0 (file:///projects/hello)
    Finished dev [unoptimized + debuginfo] target(s) in 0.42s
     Running `target/debug/hello`
Request: GET / HTTP/1.1
Host: 127.0.0.1:7878
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64; rv:52.0) Gecko/20100101
Firefox/52.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-US,en;q=0.5
Accept-Encoding: gzip, deflate
Connection: keep-alive
Upgrade-Insecure-Requests: 1
������������������������������������
```

В зависимости от вашего браузера, вы можете получить немного другие результаты. Теперь, когда мы печатаем данные запроса, мы можем понять, почему мы получаем несколько соединений от одного запроса браузера посмотрев на путь после `Request: GET`. Если повторные соединения запрашивают путь */*, мы знаем, что браузер пытается запросить */* повторно, потому что он не получает ответ от нашей программы.

Давайте разберём эти данные из запроса, чтобы понять, что запрашивает браузер у нашей программы.

### Пристальный взгляд на HTTP запрос

HTTP - это текстовый протокол и запрос имеет следующий формат:

```text
Method Request-URI HTTP-Version CRLF headers CRLF message-body
```

Первая строка - это *строка запроса* (request line), которая содержит информацию о том, что запрашивает клиент. Первая часть строки запроса указывает используемый *метод*, например, `GET` или `POST`, который описывает, как клиент делает этот запрос. Наш клиент использовал запрос `GET`.

Следующая часть строки запроса - это символ */*, который указывает на *унифицированный идентификатор ресурса* *(URI - Uniform Resource Identifier)*, который запрашивается клиентом: URI является почти, но не совсем тем же что и *универсальный указатель ресурса* *(URL - Uniform Resource Locator)*. Разница между URI и URL адресами не важна для целей в этой главе, но спецификация HTTP использует термин URI, поэтому мы можем просто мысленно заменить URL на URI.

Последняя часть - это версия HTTP, которую использует клиент, а затем строка запроса заканчивается *CRLF последовательностью*. (CRLF означает *возврат каретки* (CR - carriage return) и *перевод строки* (LF - line feed), являющиеся терминами с дней пишущих машинок!) Последовательность CRLF также может записывается как `\r\n`, где `\r` - возврат каретки, а `\n` - перевод строки. Последовательность CRLF отделяет строку запроса от остальной части данных запроса. Обратите внимание, что при печати CRLF мы видим как начало новой строки, а не как `\r\n`.

Глядя на данные строки запроса, которые мы получили при запуске программы, мы видим что `GET` - это метод, */* - это URI запроса, а `HTTP/1.1` - это версия протокола.

Строки, оставшиеся после строки с запросом, начиная с заголовка `Host:` и далее, являются заголовками. `GET` запросы не имеют тела запроса.

Попробуйте сделать запрос из другого браузера или запросить другой адрес, такой как *127.0.0.1:7878/test*, чтобы увидеть как изменяются данные запроса.

Теперь, когда мы знаем, что запрашивает браузер, давайте отправим обратно в ответ некоторые данные!

### Написание ответа

Теперь мы реализуем отправку данных в ответ на запрос клиента. Ответы имеют следующий формат:

```text
HTTP-Version Status-Code Reason-Phrase CRLF headers CRLF message-body
```

Первая строка является *строкой состояния*, содержащая версию HTTP используемого для ответа, числовой код состояния, который суммирует результат запроса и фразу причины, которая представляет текстовое описание кода состояния. После последовательности CRLF находятся любые заголовки, другая последовательность CRLF и тело ответа.

Вот пример ответа, который использует HTTP версии 1.1, имеет код состояния равный 200, фразу успешного ответа OK, без заголовков и без тела:

```text
HTTP/1.1 200 OK\r\n\r\n
```

Код состояния 200 является стандартным ответом об успехе. Данный текст это короткий успешный HTTP ответ. Давайте запишем его в поток как ответ на успешный запрос! Из функции `handle_connection` удалите `println!`, который печатал данные запроса и замените его кодом в листинге 20-3.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
# use std::io::prelude::*; # use std::net::TcpStream; fn handle_connection(mut stream: TcpStream) {     let mut buffer = [0; 512];      stream.read(&mut buffer).unwrap();      let response = "HTTP/1.1 200 OK\r\n\r\n";      stream.write(response.as_bytes()).unwrap();     stream.flush().unwrap(); }
```

<span class="caption">Листинг 20-3: Запись короткого успешного HTTP ответа в поток</span>

Первая новая строка определяет переменную `response`, которая содержит данные для  успешного сообщения. Затем мы вызываем `as_bytes` у переменной `response`, чтобы преобразовать строку в  байт данные. Метод `write` у `stream` принимает `&[u8]` и отправляет эти байты напрямую в соединение.

Поскольку операция `write` могла завершиться неудачно, мы как и ранее используем `unwrap` для любого результата с ошибкой. Опять же, в реальном приложении вы здесь добавили бы обработку ошибок. Наконец, вызов `flush` будет ждать и не позволит программе продолжить выполнение, пока все байты ответа записываются в соединение; `TcpStream` содержит внутренний буфер для минимизации вызовов базовой операционной системы.

Сделав этим изменения давайте запустим код и сделаем запрос. Мы больше не выводим в терминал любые данные, поэтому мы не увидим ничего, кроме вывода из Cargo. Когда вы загружаете адрес *127.0.0.1:7878* в веб-браузер, вы должны получить пустую страницу вместо ошибки. Вы только что вручную закодировали запрос и ответ HTTP!

### Возвращение реального HTML

Давайте реализуем функциональность для возврата больше чем пустой страницы. Создайте новый файл *hello.html*, находящийся в корневом каталоге вашего проекта, а не в каталоге *src*. Вы можете поместить любой HTML код, который вы хотите; листинг 20-4 показывает возможный вариант.

<span class="filename">Файл: hello.html</span>

```html
<!DOCTYPE html> <html lang="en">   <head>     <meta charset="utf-8">     <title>Hello!</title>   </head>   <body>     <h1>Hello!</h1>     <p>Hi from Rust</p>   </body> </html>
```

<span class="caption">Листинг 20-4: Пример HTML файла для возврата в ответ</span>

Это минимальный HTML5 документ с заголовком и текстом. Чтобы вернуть его из сервера при получении запроса клиента, мы поменяем функцию `handle_connection` как показано в коде листинга 20-5 для чтения HTML файла, добавлению его в тело ответа и его отправки.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
# use std::io::prelude::*; # use std::net::TcpStream; use std::fs; // --snip--  fn handle_connection(mut stream: TcpStream) {     let mut buffer = [0; 512];     stream.read(&mut buffer).unwrap();      let contents = fs::read_to_string("hello.html").unwrap();      let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", contents);      stream.write(response.as_bytes()).unwrap();     stream.flush().unwrap(); }
```

<span class="caption">Листинг 20-5: Отправка содержимого <em>hello.html</em> как тело ответа</span>

Мы добавили строчку вверху, чтобы подключить модуль файловой системы из стандартной библиотеки в область видимости. Код для чтения содержимого файла в строковую переменную должен быть знаком; мы использовали его в главе 12, когда читали содержимое файла для нашего проекта ввода-вывода в листинге 12-4.

Далее мы используем макрос `format!`, чтобы добавить содержимое файла как тело успешного ответ.

Запустите этот код командой `cargo run` и загрузите *127.0.0.1:7878* в браузере; вы должны увидеть выведенный HTML в браузере!

В настоящее время мы игнорируем данные запроса в `buffer` и просто отправляем в ответ содержимое файла HTML. Это означает, что если вы попытаетесь запросить *127.0.0.1:7878/something-else* в браузере, вы все равно получите тот же HTML ответ. Наш сервер реализован очень ограниченным и это не то, что делают большинство веб-серверов. Мы хотим настроить наши ответы в зависимости от запроса и отправлять в ответ HTML файл для правильно сформированного запроса для пути */*.

### Проверка запроса и выборочное возвращение ответа

Прямо сейчас наш веб-сервер вернёт HTML из файла независимо от того, что запросил клиент. Давайте добавим функциональность, чтобы проверить, что браузер запрашивает */* перед возвратом HTML файла и вернём ошибку, если браузер запрашивает что-нибудь другое. Для этого нам нужно изменить `handle_connection` как показано в листинге 20-6. Этот новый код проверяет содержание запроса сравнивая его с  запросом ресурса */* и добавим блоки `if` и `else` для разной обработки запросов.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
# use std::io::prelude::*; # use std::net::TcpStream; # use std::fs; // --snip--  fn handle_connection(mut stream: TcpStream) {     let mut buffer = [0; 512];     stream.read(&mut buffer).unwrap();      let get = b"GET / HTTP/1.1\r\n";      if buffer.starts_with(get) {         let contents = fs::read_to_string("hello.html").unwrap();          let response = format!("HTTP/1.1 200 OK\r\n\r\n{}", contents);          stream.write(response.as_bytes()).unwrap();         stream.flush().unwrap();     } else {         // some other request     } }
```

<span class="caption">Листинг 20-6: Сопоставление запроса и обработка запросов для корневого ресурса <em>/</em>, отличающимся от запросов других ресурсов</span>

Сначала мы жёстко закодируем данные, соответствующие коревому запросу */* в переменной `get`. Поскольку мы читаем сырые байты в буфер, мы конвертирует `get` в строку байт, добавляя в начале содержимого строки символ `b""` байт синтаксиса. Затем мы проверяем, начинается ли `buffer` с байтов как в переменной `get`. Если это так, то это означает, что мы получили правильно сформированный запрос ресурса */*, что является успешным случаем обработанным в блоке `if`, который возвращает содержимое HTML файла.

Если `buffer` *не начинается* байтами из переменной `get`, то это означает, что мы получили какой-то другой запрос. Мы скоро добавим код в блок `else`, чтобы ответить на все остальные запросы.

Запустите этот код и запросите адрес *127.0.0.1:7878* в браузере. Вы должны получить HTML из файла *hello.html*. Если вы сделаете любой другой запрос, такой как *127.0.0.1:7878/something-else*, то получите ошибку соединения, подобную той что вы видели при запуске кода листинга 20-1 и 20-2.

Теперь давайте добавим код в листинг 20-7 внутрь блока `else`, чтобы вернуть ответ с кодом состояния 404, который сигнализирует о том, что контент запроса не был найден. Мы также вернём HTML для страницы, отображаемой в браузере с указанием ответа конечному пользователю.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
# use std::io::prelude::*; # use std::net::TcpStream; # use std::fs; # fn handle_connection(mut stream: TcpStream) { # if true { // --snip--  } else {     let status_line = "HTTP/1.1 404 NOT FOUND\r\n\r\n";     let contents = fs::read_to_string("404.html").unwrap();      let response = format!("{}{}", status_line, contents);      stream.write(response.as_bytes()).unwrap();     stream.flush().unwrap(); } # }
```

<span class="caption">Листинга  20-7: Отвечаем кодом состояния 404 и страницей ошибки, если было запрошено что-то отличающееся от ресурса <em>/</em></span>

Здесь ответ имеет строку состояния с кодом 404 и фразу причины `NOT FOUND`. Мы по-прежнему не возвращаем заголовки, а тело ответа будет HTML из файла *404.html*. Вам нужно создать файл *404.html* рядом с *hello.html* для этой страницы ошибки; снова не стесняйтесь использовать любой HTML код или пример HTML кода в листинге 20-8.

<span class="filename">Файл: 404.html</span>

```html
<!DOCTYPE html> <html lang="en">   <head>     <meta charset="utf-8">     <title>Hello!</title>   </head>   <body>     <h1>Oops!</h1>     <p>Sorry, I don't know what you're asking for.</p>   </body> </html>
```

<span class="caption">Листинг 20-8: Пример содержимого страницы для отправки с любым ответом 404</span>

Запустите сервер снова вместе со внесёнными изменениями. Запрашивая *127.0.0.1:7878* сервер должен вернуть содержимое файла *hello.html*, а любой другой запрос вроде *127.0.0.1:7878/foo*, должен вернуть HTML страницу ошибки *404.html*.

### Рефакторинг

На данный момент блоки `if` и `else` имеют много повторяющегося кода: они оба читают файлы и записывают содержимое файла в поток. Единственными отличиями являются строка состояния и имя файла. Давайте сделаем код более кратким, выделив эти различия в отдельные строки `if` и `else` которые будут присваивать значения строки состояния и имени файла переменным; затем мы можем просто использовать эти переменные в коде для чтения файла и записи ответа. Код в листинге 20-9 показывает полученный код после переделки больших блоков `if` и `else`.

<span class="filename">Файл: src/main.rs</span>

```rust,no_run
# use std::io::prelude::*; # use std::net::TcpStream; # use std::fs; // --snip--  fn handle_connection(mut stream: TcpStream) { #     let mut buffer = [0; 512]; #     stream.read(&mut buffer).unwrap(); # #     let get = b"GET / HTTP/1.1\r\n";     // --snip--      let (status_line, filename) = if buffer.starts_with(get) {         ("HTTP/1.1 200 OK\r\n\r\n", "hello.html")     } else {         ("HTTP/1.1 404 NOT FOUND\r\n\r\n", "404.html")     };      let contents = fs::read_to_string(filename).unwrap();      let response = format!("{}{}", status_line, contents);      stream.write(response.as_bytes()).unwrap();     stream.flush().unwrap(); }
```

<span class="caption">Листинг 20-9: Рефакторинг блоков <code>if</code> и <code>else</code>, содержащих только код различающийся в обоих случаях</span>

Теперь блоки `if` и `else` возвращают только соответствующие значения для строки состояния и имени файла в кортеже; Затем мы используем деструктуризацию для назначения кортежа значениям двух переменных `status_line` и `filename` с использованием шаблона в выражении `let`, что обсуждалось в главе 18.

Ранее дублированный код теперь находится вне блоков `if` и `else` и использует переменные `status_line` и `filename`. Это позволяет легче увидеть разницу между этими двумя случаями и означает, что у нас есть только одно место для обновления кода, если захотим изменить работу чтения файлов и записи ответов. Поведение кода в листинге 20-9 будет таким же, как и в 20-8.

Потрясающие! Теперь у нас есть простой веб-сервер из примерно 40 строк кода Rust, который отвечает на один запрос страницей контента и отвечает на все другие запросы ответом с ошибкой 404.

В данное время сервер работает в одном потоке, то есть он может обслуживать только один запрос за один раз. Давайте рассмотрим, как почему это может стать проблемой с помощью моделирования медленных запросов. Затем мы исправим эту проблему, чтобы наш сервер мог обрабатывать несколько запросов одновременно.
