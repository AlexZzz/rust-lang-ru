## Переменные и изменяемость

Как упоминалось в разделе ["Хранение значений с помощью переменных"](ch02-00-guessing-game-tutorial.html#storing-values-with-variables), по умолчанию переменные неизменяемы. Это один из многих стимулов Rust, позволяющий писать код с использованием преимущества безопасности и удобной конкурентности (concurrency), предоставляемых Rust. Тем не менее, существует возможность сделать переменные изменяемыми. Давайте рассмотрим, как и почему Rust побуждает предпочесть неизменяемость и почему иногда можно отказаться от этого.

Если переменная является неизменяемой, то после привязки значения к имени изменить его будет нельзя. Чтобы показать это, создайте новый проект под названием *variables* в каталоге *projects* с помощью команды `cargo new variables`.

Далее, в новом каталоге *variables* откройте *src/main.rs* и замените в нем код на ниже приведенный, который пока не будет компилироваться:

<span class="filename">Имя файла: src/main.rs</span>

```rust,ignore,does_not_compile
fn main() {
let x = 5;
println!("The value of x is: {}", x);
x = 6;
println!("The value of x is: {}", x);
}
```

Сохраните и запустите программу, используя `cargo run`. Будет получено сообщение об ошибке относительно неизменяемости, как показано в этом выводе:

```console
error[E0384]: cannot assign twice to immutable variable `x`  --> src/main.rs:4:5   | 2 |     let x = 5;   |         - first assignment to `x` 3 |     println!("The value of x is: {}", x); 4 |     x = 6;   |     ^^^^^ cannot assign twice to immutable variable
```

В этом примере показано, как компилятор помогает находить ошибки в ваших программах. Ошибки компилятора могут расстраивать, но в действительности они означают, что программа пока не делает правильно то, что вы ожидаете; это *не значит*, что вы плохой программист! Даже опытные Rustaceans иногда сталкиваются с ошибками компилятора.

Вы получили сообщение об ошибке `cannot assign twice to immutable variable `x``, потому что попытались присвоить новое значение неизменяемой переменной `x`.

Важно, чтобы при попытке изменить значение, объявленное неизменяемым, выдавались ошибки времени компиляции, так как подобная ситуация может привести к сбоям. Если одна часть нашего кода функционирует исходя из уверенности в неизменяемости значения, а другая часть изменяет это значение, то велика вероятность , что первая часть не выполнит своего предназначения. Причину такой ошибки бывает трудно отследить, особенно если вторая часть кода изменяет значение лишь *изредка*. Компилятор Rust предоставляет гарантию, что если объявить значение неизменяемым, то оно действительно не изменится, а значит, не нужно следить за этим самим. Таким образом, ваш код становится проще для понимания.

Однако изменяемость может быть очень полезной и может сделать код более удобным для написания. Хотя переменные по умолчанию неизменяемы, их можно сделать изменяемыми, добавив `mut` перед именем переменной, как это было сделано в [Главе 2](ch02-00-guessing-game-tutorial.html#storing-values-with-variables). Добавление `mut` также передает будущим читателям кода намерение, обозначая, что другие части кода будут изменять значение этой переменной.

Например, изменим *src/main.rs* на следующий код:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/src/main.rs}}
```

Запустив программу, мы получим результат:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-02-adding-mut/output.txt}}
```

Нам разрешено изменить значение, связанное с x, с 5 на 6 при помощи mut. В конечном счете, решение об использовании изменяемости остается за вами и зависит от вашего мнения о наилучшем варианте в данной конкретной ситуации.

### Константы

Подобно неизменяемым переменным, *константы* — это значения, которые связаны с именем и не могут изменяться, но между константами и переменными есть несколько различий.

First, you aren’t allowed to use `mut` with constants. Constants aren’t just immutable by default—they’re always immutable. You declare constants using the `const` keyword instead of the `let` keyword, and the type of the value *must* be annotated. We’ll cover types and type annotations in the next section, [“Data Types”](ch03-02-data-types.html#data-types)<!-- ignore -->, so don’t worry about the details right now. Just know that you must always annotate the type.

Константы можно объявлять в любой области видимости, включая глобальную, благодаря этому они полезны для значений, которые нужны во многих частях кода.

Последнее отличие в том, что константы могут быть заданы только константным выражением, но не результатом вычисленного во время выполнения значения.

Вот пример объявления константы:

```rust
const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
```

Имя константы - `THREE_HOURS_IN_SECONDS`, а ее значение устанавливается как результат умножения 60 (количество секунд в минуте) на 60 (количество минут в часе) на 3 (количество часов, которые нужно посчитать в этой программе). Соглашение Rust для именования констант требует использования всех заглавных букв с подчеркиванием между словами. Компилятор может вычислять ограниченный набор операций во время компиляции, позволяющий записать это значение более понятным и простым для проверки способом, чем установка этой константы в значение 10 800. Дополнительную информацию о том, какие операции можно использовать при объявлении констант, см. в разделе [Раздел справки Rust по вычислениям констант](../reference/const_eval.html).

Константы существуют в течение всего времени работы программы в пределах области, в которой они были объявлены. Это свойство делает константы полезными для значений в домене вашего приложения, о которых могут знать несколько частей программы, например, максимальное количество очков, которое может заработать любой игрок в игре, или скорость света.

Обозначение жестко закодированных значений, используемых в программе, как константы полезно для передачи смысла этого значения будущим сопровождающим кода. Это также позволяет иметь единственное место в коде, которое нужно будет изменить, если в будущем потребуется обновить значение.

### Затенение (переменных)

Как было показано в уроке по игре в угадайку в [главе 2](ch02-00-guessing-game-tutorial.html#comparing-the-guess-to-the-secret-number), можно объявить новую переменную с тем же именем, как и у существующей переменной. Rustaceans говорят, что первая переменная *затеняется* второй, то есть вторая переменная - это то, что увидит компилятор, когда вы будете использовать имя переменной. По сути, вторая переменная затеняет первую, принимая любое использование имени переменной на себя до тех пор, пока либо она сама не станет тенью, либо не закончится область видимости. Мы можем затенять переменную, используя то же имя переменной и повторяя использование ключевого слова `let` следующим образом:

<span class="filename">Имя файла: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/src/main.rs}}
```

Эта программа сначала привязывает `x` к значению `5`. Затем она создаёт новую переменную `x`, повторяя `let x =`, беря исходное значение и добавляя `1`, чтобы значение `x` стало равным `6`. Затем во внутренней области видимости, созданной с помощью фигурных скобок, третий оператор `let` также затеняет `x` и создаёт новую переменную, умножая предыдущее значение на `2`, чтобы дать `x` значение `12`. Когда эта область заканчивается, внутреннее затенение заканчивается, и `x` возвращается к значению `6`. Запустив эту программу, она выведет следующее:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-03-shadowing/output.txt}}
```

Shadowing is different from marking a variable as `mut` because we’ll get a compile-time error if we accidentally try to reassign to this variable without using the `let` keyword. By using `let`, we can perform a few transformations on a value but have the variable be immutable after those transformations have been completed.

Другой разницей между `mut` и затенением является то, что мы создаём совершенно новую переменную, когда снова используем слово `let` (ещё одну). Мы можем даже изменить тип значения, но снова использовать прежнее имя. К примеру, наша программа спрашивает пользователя, сколько пробелов он хочет разместить между некоторым текстом, запрашивая символы пробела, но мы на самом деле хотим сохранить данный ввод как число:

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-04-shadowing-can-change-types/src/main.rs:here}}
```

Первая переменная `spaces` — является строковым типом, а вторая переменная `spaces` — числовым типом. Таким образом, затенение избавляет нас от необходимости придумывать разные имена, такие как `spaces_str` и `spaces_num`. Вместо этого мы можем повторно использовать более простое имя `spaces`. Однако, если мы попытаемся использовать для этого `mut`, как показано далее, то получим ошибку времени компиляции:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/src/main.rs:here}}
```

Ошибка говорит, что не разрешается менять тип переменной:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-05-mut-cant-change-types/output.txt}}
```

Теперь, когда мы изучили, как работают переменные, давайте рассмотрим различные типы данных, которые они могут иметь.
