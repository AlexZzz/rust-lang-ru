## Определение и инициализация структур

Внешне структуры похожи на кортежи рассмотренные в главе 3. Также как кортежи, структуры могут содержать разные типы данных. Но в отличии от кортежей, вы именуете части данных так, чтобы было ясно что эти имена означают. Поэтому структуры более удобны для создания новых типов данных, так как нет необходимости запоминать порядковый номер какого-либо значения внутри экземпляра структуры.

Для определения структуры, указывается ключевое слово `struct` и её название. Название должно описывать значение частей данных сгруппированных вместе. Далее, в фигурных скобках для каждой новой части данных поочередно определяются имя части данных и её тип. Каждая пара <code>имя: тип</code> называется *полем*. Листинг 5-1, описывает структуру для хранения информации о учётной записи пользователя:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-01/src/main.rs:here}}
```

<span class="caption">Листинг 5-1: определение структуры <code>User</code></span>

После определения структуры можно создавать её *экземпляр*, назначая определённое значение каждому полю с соответствующим типом данных. Экземпляр создаётся, указывая имя структуры, затем добавляем фигурные скобки включающие пары `ключ: значение` (key: value), где ключами являются имена полей и значениями являются данные, которые мы хотим сохранить в поля. Нет необходимости чётко следовать порядку объявления полей в описании структуры (но всё-таки желательно, для удобства чтения). Другими словами, объявление структуры - это как шаблон нашего типа, в то время как экземпляр структуры использует этот шаблон, заполняя его определёнными данными, для создания значений нашего типа. Например, можно объявить пользователя как в листинге 5-2:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-02/src/main.rs:here}}
```

<span class="caption">Листинг 5-2: создание экземпляра <code>user1</code> структуры <code>User</code></span>

Чтобы получить определённое значение поля структуры, мы можем использовать точечную нотацию (как в кортеже). Если нужен только электронный адрес, можно использовать `user1.email` везде, где нужно его значение. Если объявить экземпляр структуры изменяемым, то мы сможем при помощи точечной нотации и присвоения так же и изменить значение поля. Листинг 5-3 показывает как изменить значение в поле `email` изменяемого экземпляра `User`:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-03/src/main.rs:here}}
```

<span class="caption">Листинг 5-3: изменение значения поля <code>email</code> экземпляра структуры <code>User</code></span>

Заметим, что весь экземпляр структуры должен быть изменяемым. Rust не позволяет помечать изменяемыми отдельные поля. <br><br>Как и для любого другого выражения, мы можем использовать выражение создания структуры в качестве последнего выражения тела функции для явного возврата нового экземпляра.

На листинге 5-4 функция `build_user` возвращает экземпляр `User` с указанным адресом и именем. Поле `active` получает значение `true`, а поле `sign_in_count` получает значение `1`.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-04/src/main.rs:here}}
```

<span class="caption">Листинг 5-4: функция <code>build_user</code> принимает электронный адрес, имя и возвращает экземпляр <code>User</code></span>

В таком случае имеет смысл называть имена входных параметров функции так же, как и названия полей структуры. Однако, повторение названия полей структуры `email` и `username` и название входных переменных `email` и `username` в выражении создания структуры выглядит не удобно. Если структура имеет много полей, то подобное повторение станет более раздражающим. К счастью есть удобное сокращение!

### Использование сокращённой инициализации для случаев, когда имена поля структуры и входной переменной функции совпадают

Так как имена входных параметров функции и полей структуры являются полностью идентичными в листинге 5-4, возможно использовать синтаксис *сокращённой инициализации поля*, чтобы переписать `build_user` так, чтобы он работал точно также, но не содержал повторений для `email` и `username`, как в листинге 5-5.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-05/src/main.rs:here}}
```

<span class="caption">Листинг 5-5: функция <code>build_user</code> использует сокращённую инициализацию полей, потому что её входные параметры <code>email</code> и <code>username</code> имеют имена аналогичные именам полей структуры</span>

Здесь происходит создание нового экземпляра структуры `User`, которая имеет поле с именем `email`. Мы хотим установить поле структуры `email` значением входного параметра `email` функции `build_user`. Так как поле `email` и входной параметр функции `email` имеют одинаковое название, можно писать просто `email` вместо кода `email: email`.

### Создание экземпляра структуры из экземпляра другой структуры с помощью синтаксиса обновления структуры

Часто является полезным создание нового экземпляра структуры, который использует значения старого экземпляра, но что-то меняет в нем. Это делается с помощью *синтаксиса обновления структур*.

Сначала листинг 5-6 показывает как создать новый экземпляр `User` для переменной `user2` без синтаксиса обновления. Устанавливаются значения `email` и `username`, но используются те же значения из переменной `user1`, как сделано в листинге 5-2.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-06/src/main.rs:here}}
```

<span class="caption">Листинг 5-6: создание экземпляра <code>User</code> с присвоением некоторым полям значений из <code>user1</code></span>

Используя синтаксис обновления структуры, можно получить тот же эффект, используя меньше кода как показано в листинге 5-7. Синтаксис `..` указывает, что оставшиеся поля устанавливаются не явно и должны иметь значения из указанного экземпляра.

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/listing-05-07/src/main.rs:here}}
```

<span class="caption">Листинг 5-7: используем синтаксис обновления структур для установки значений <code>email</code> и <code>username</code> экземпляра <code>User</code>, но для остальных значений берем данные из полей экземпляра переменной <code>user1</code></span>

Код в листинге Listing 5-7 также создаёт экземпляр переменной `user2`, который имеет отличные от `user1` значения `email` и `username`, но те же что у `user1` значения для полей `active` и `sign_in_count`.

### Кортежные структуры: структуры без именованных полей для создания разных типов

Можно определять структуры с помощью сокращённой записи, очень напоминающей кортежи (такое определение называют *кортежными структурами, tuple structs*). Кортежная структура имеет дополнительное значение из-за имени в объявлении, но не имеет имён ассоциированных с её полями, у них есть только типы. Кортежные структуры удобны, когда нужно дать всему кортежу имя и сделать его отличным от других кортежей, при этом именование полей как у обычной структуры будет подробным или избыточным.

Определение кортежной структуры начинается ключевым словом `struct`, названием структуры, за названием следуют типы в кортеже. Например, вот определение и использование двух кортежных структур с именами `Color` и `Point`:

```rust
{{#rustdoc_include ../listings/ch05-using-structs-to-structure-related-data/no-listing-01-tuple-structs/src/main.rs:here}}
```

Обратите внимание, что переменные `black` и `origin` разного типа, потому что они являются экземплярами разных кортежных структур. Каждая определяемая структура является собственным типом, не смотря на то, что поля внутри структуры имеют одинаковые типы. Например, функция принимающая параметром тип `Color` не может принять аргумент типа `Point`, не смотря на то, что оба типа состоят из трёх значений `i32`. Тем не менее, экземпляры кортежных структур ведут себя как кортежи: их можно разделять на отдельные части, использовать `.` за которой идёт индекс для доступа к отдельному значению и т.д.

### Единично-подобные структуры: структуры без полей

Можно также определять структуры без полей! Они называются *unit-like, единично-подобные структуры* потому что ведут себя подобно единичному типу `()`. Единично-подобные структуры могут быть полезны в ситуации, в которой нужно реализовать типаж некоторого типа, но нет никаких данных для сохранения в самом типе. Мы обсудим типажи в главе 10.

> ### Владение данными структуры
> При определении структуры `User` листинга 5-1 мы использовали тип `String` владеющий данными вместо `&str`. Это было осознанное решение, т.к. мы хотели, чтобы экземпляры структур владели всеми своими данными и чтобы данные были действительными во время всего существования структуры.
> Возможно сделать так, чтобы структуры сохраняли ссылки на данные которыми владеет кто-то другой, но это требует использования функциональности  *времён жизни (lifetimes)* Rust, о которой мы поговорим в главе 10. Времена жизни гарантируют, что данные на которые ссылается структура, действительны столько же времени, сколько действительна сама структура. Допустим, вы пробуете сохранить ссылку в структуре без указания времени жизни, вот так, но это не будет работать:
> <span class="filename"><span>Файл: src/main.rs</span></span>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
> ```rust,ignore,does_not_compile
>  struct User {
>      username: &str,
>      email: &str,
>      sign_in_count: u64,
>      active: bool,
>  }
>
>  fn main() {
>      let user1 = User {
>          email: "someone@example.com",
>          username: "someusername123",
>          active: true,
>          sign_in_count: 1,
>      };
>  }
> ```
> Компилятор будет жаловаться на необходимость определения времени жизни ссылок:
> ```console
> $ cargo run
>    Compiling structs v0.1.0 (file:///projects/structs)
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:2:15
>   |
> 2 |     username: &str,
>   |               ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 | struct User<'a> {
> 2 |     username: &'a str,
>   |
>
> error[E0106]: missing lifetime specifier
>  --> src/main.rs:3:12
>   |
> 3 |     email: &str,
>   |            ^ expected named lifetime parameter
>   |
> help: consider introducing a named lifetime parameter
>   |
> 1 | struct User<'a> {
> 2 |     username: &str,
> 3 |     email: &'a str,
>   |
>
> error: aborting due to 2 previous errors
>
> For more information about this error, try `rustc --explain E0106`.
> error: could not compile `structs`
>
> To learn more, run the command again with --verbose.
> ```
> В главе 10 мы обсудим, как исправить такие ошибки сохранения ссылок в структурах. Но сейчас мы просто забудем об этих ошибках и будем использовать типы с владением данными, такими как `String` заместо типа ссылок, таких как `&str`.

<!-- manual-regeneration
for the error above
after running update-rustc.sh:
pbcopy < listings/ch05-using-structs-to-structure-related-data/no-listing-02-reference-in-struct/output.txt
paste above
add `> ` before every line -->
