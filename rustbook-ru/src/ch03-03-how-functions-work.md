## Функции

Функция - это ключевые части Rust кода. Вы, конечно, знакомы с самой важной функцией. Это функция `main`, которая является точкой входа программ. Также вы уже познакомились с ключевым словом `fn`, позволяющим объявить новую функцию.

В Rust используется т.н.*"змеиный"* (snake case) стиль написания функций и переменных: это когда все слова пишутся в нижнем регистре и слова в многословных обозначениях разделяются нижним подчёркиванием. Пример объявления функции:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-16-functions/src/main.rs}}
```

Определение функции начинается с `fn` и состоит из группы скобок после имени функции. Фигурные скобки указывают, где начинается и заканчивается тело функции.

Мы можем вызвать любую функцию которую мы объявили, введя её имя и скобки за именем. Так как `another_function` определена в программе, её можно вызвать из функции `main`. Заметьте, что мы определили `another_function` *после* функции `main` в исходном коде; мы также могли бы определить её до `main`. Rust не волнует, в каком месте файла с кодом вы определяете свои функции, главное только то, что они где-то определены.

Создадим новый проект с названием *functions* для дальнейшего изучения функций. Поместите пример `another_function` в файл *src/main.rs* и запустите его. Вы должны увидеть следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-16-functions/output.txt}}
```

Строчки кода выполняются в том порядке, в котором они появляются в функции `main`. Сначала печатается сообщение "Hello, world!", а затем вызывается `another_function` и она также печатает сообщение.

### Параметры функции

Функции также можно объявлять с *параметрами*, которые являются специальными переменными и частью сигнатуры функции. Когда у функции есть параметры, то для неё можно предоставлять конкретные значения этих параметров. Технически, конкретные параметры называются *аргументами*, но в обычном разговоре люди часто используют слово *параметр* и *аргумент* взаимозаменяемо, для переменной в описании функции или для конкретных значений аргументов при вызове функции.

Переписанная версия функции `another_function` показывает, как параметры выглядят в Rust:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/src/main.rs}}
```

Попробуйте запустить программу, вы должны получить следующий вывод:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-17-functions-with-parameters/output.txt}}
```

Объявление функции `another_function` имеет один параметр с именем `x`. Тип параметра `x` определён как `i32`. Когда значение `5` передаётся в функцию `another_function`, то макрос  `println!` помещает число `5` в том месте форматированной строки, где находится пара фигурных скобок.

В сигнатуре функции вы *должны* указать тип каждого параметра. Это осознанное решение в дизайне языка Rust: требование аннотации типов в определении функции означает, что компилятору почти никогда не нужно ничего использовать ещё откуда-то из кода для понимания, какой тип у данного параметра вы подразумевали.

Когда у функции множество параметров, то они разделяются с помощью запятой, как тут:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/src/main.rs}}
```

Данный пример создаёт функцию с двумя параметрами, оба из которых имеют тип `i32`. Функция затем печатает значения обоих параметров. Заметьте, что параметры функции не должны быть все одного типа, просто так получилось в этом примере.

Попробуем запустить этот код. Замените программу из проекта  *functions* в файле *src/main.rs* следующим примером и запустите его командой `cargo run`:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-18-functions-with-multiple-parameters/output.txt}}
```

Так как мы вызвали функцию со значением `5` в параметре `x` а число `6` было передано в `y`, две строки в функции напечатали эти два значения.

### Тело функции состоит из операторов и выражений

Тело функции состоит из серии операторов, которое опционально может заканчиваться выражением. До этого времени, мы ещё не рассматривали функции тело которых оканчивается в конце выражением, а рассматривали выражения как часть операторов в теле. По причине того, что Rust является языком на основе выражений, то это различие важно понимать. Другие языки могут не иметь такие различия, поэтому посмотрим что такое операции и выражения, и как различие между ними влияют на тело функций.

На самом деле мы уже использовали операторы и выражения. *Операторы (Statements)* - это инструкции, которые  выполняют действия, но не возвращают значение. *Выражения (Expressions)* вычисляются в результирующее значение, которое возвращается. Рассмотрим примеры.

Создадим переменную и присвоим ей значение с помощью ключевого слова `let`. В листинге 3-1 `let y = 6;` является оператором.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/listing-03-01/src/main.rs}}
```

<span class="caption">Листинг 3-1: Объявление функции <code>main</code> включающей один оператор</span>

Определение функции также является оператором. Весь предыдущий пример тоже является оператором.

Операции не возвращают значений. Тем не менее, нельзя назначить оператор `let` другой переменной, как это пытается сделать следующий код. Вы получите ошибку:

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/src/main.rs}}
```

Если вы запустите эту программу, то ошибка будет выглядеть так:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-19-statements-vs-expressions/output.txt}}
```

Оператор `let y = 6`не возвращает значения, так что нет ничего что можно было бы назначить переменной `x`. Такое поведение отлично от некоторых других языков, типа C и Ruby, где выражение присваивания возвращает присваиваемое значение. В таких языках можно писать код `x = y = 6` и обе переменные `x` и `y` будут иметь одинаковое значение `6`; но это не так в Rust.

Выражения обычно во что-то вычисляются и составляют большую часть кода, который вы будете писать в Rust. Рассмотрим простую математическую операцию `5 + 6`, которая является выражением вычисляющим значение `11`. Выражения могут быть частью операторов: в листинге 3-1 число `6` в операторе `let y = 6;` является выражением, которое вычисляется в значение `6`. Вызов функции является выражением. Вызов макроса является выражением. Блок используемый для создания областей видимости `{}` также является выражением, например:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-20-blocks-are-expressions/src/main.rs}}
```

Это выражение:

```rust,ignore
{
    let x = 3;
    x + 1
}
```

является блоком, который в данном случае вычисляется в число `4`. Его значение привязывается, назначается переменной `y` как часть оператора `let`. Заметьте, что строка `x + 1` не имеет точки с запятой в конце, что отличается от большинства строк, которые вы видели до сих пор. Выражения <em>не включают</em> точки с запятой в их завершении. Если её добавить в конце выражения, вы <em>превратите его в оператор</em>, который не будет возвращать значение. Имейте это в виду, по мере дальнейшего изучения возвращаемых значений функций и выражений.

### Функции возвращающие значения

Функции могут возвращать значения в вызывающий их код. Мы не именуем возвращаемые значения, но мы объявляем их тип после символа (`->`). В Rust, возвращаемое значение функции является синонимом значения последнего выражения в блоке тела функции. Можно выполнить ранний возврат из функции используя ключевое слово `return` и указав значение, но большинство функций явно возвращает последнее выражение в теле. Вот пример функции возвращающей значение:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/src/main.rs}}
```

В коде функции `five` нет вызовов функций, макросов или даже операторов  `let` - есть только одно число `5`. Это является абсолютно корректной функцией в Rust. Заметьте, что возвращаемый тип у данной функции определён как `-> i32`. Попробуйте запустить; вывод будет таким:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-21-function-return-values/output.txt}}
```

Число `5` в функции `five` является возвращаемым значением функции (можно сказать что <em>функция `five` вычисляется в `5`</em>), вот почему возвращаемым типом является `i32`. Рассмотрим пример более детально. Есть два важных момента: первый строка `let x = five();` показывает, что мы используем значение возвращаемое функцией для инициализации переменной. Так как функция `five` возвращает `5`, то эта строка эквивалентна следующей:

```rust
let x = 5;
```

Второй момент, функция `five` не имеет входных параметров и определяет тип возвращаемого значения. Само тело функции - единственная `5` без точки с запятой. Т.к. мы хотим, чтобы функция возвращала значение, последняя строка функции должна быть выражением (не иметь после себя знак точки с запятой). В данной функции мы хотим вернуть `5` - по этому `5` должно быть выражением (не должно иметь после себя знак точки с запятой).

Рассмотрим другой пример:

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-22-function-parameter-and-return/src/main.rs}}
```

Запуск кода выведет `The value of x is: 6`. Но если поместить точку с запятой в конец строки, включающей `x + 1`, то это изменит её с выражения на оператор и мы получим ошибку.

<span class="filename">Файл: src/main.rs</span>

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/src/main.rs}}
```

Компиляция данного кода вызывает следующую ошибку:

```console
{{#include ../listings/ch03-common-programming-concepts/no-listing-23-statements-dont-return-values/output.txt}}
```

Главное сообщение в ошибке, “mismatched types” раскрывает основную проблему этого кода. Определение функции `plus_one` обещает, что она вернёт значение типа `i32`, однако теперь уже она заканчивается оператором, а оператор не вычисляет значение, что отображено символами пустого кортежа (empty tuple) - круглыми скобками `()`  в описании ошибки. Поэтому, здесь ничего не возвращается, что противоречит определению функции и приводит к ошибке. В данном выводе Rust предлагает свою помощь в сообщении, чтобы исправить проблему: он советует убрать точку с запятой (сделать оператор вновь выражением), что должно исправить ошибку.
