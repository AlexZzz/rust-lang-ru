## Исправимые ошибки с `Result`

Многие ошибки являются не настолько критичными, чтобы останавливать выполнение программы. Иногда, когда в функции происходит сбой, необходима просто правильная интерпретация и обработка ошибки. К примеру, при попытке открыть файл может произойти ошибка из-за отсутствия файла. Вы, возможно, захотите исправить ситуацию и создать новый файл вместо остановки программы.

Вспомните раздел ["Обработка потенциального сбоя с помощью типа `Result`"](ch02-00-guessing-game-tutorial.html#handling-potential-failure-with-the-result-type)<!-- ignore --> главы 2: мы использовали там перечисление `Result`, имеющее два варианта, `Ok` и `Err` для обработки сбоев. Само перечисление определено следующим образом:

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

The `T` and `E` are generic type parameters: we’ll discuss generics in more detail in Chapter 10. What you need to know right now is that `T` represents the type of the value that will be returned in a success case within the `Ok` variant, and `E` represents the type of the error that will be returned in a failure case within the `Err` variant. Because `Result` has these generic type parameters, we can use the `Result` type and the functions defined on it in many different situations where the successful value and error value we want to return may differ.

Давайте вызовем функцию, которая возвращает значение `Result`, потому что может потерпеть неудачу. В листинге 9-3 мы пытаемся открыть файл.

<span class="filename">Файл: src/main.rs</span>

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-03/src/main.rs}}
```

<span class="caption">Листинг 9-3: Открытие файла</span>

Откуда мы знаем, что `File::open` возвращает `Result`? Мы могли бы посмотреть [документацию по API стандартной библиотеки ](../std/fs/struct.File.html#method.open) <!--  --> или мы могли бы спросить компилятор! Если мы припишем переменной `f` тип, *отличный* от возвращаемого типа функции, а затем попытаемся скомпилировать код, компилятор скажет нам, что типы не совпадают. Сообщение об ошибке подскажет нам, каким <em>должен быть</em> тип <code>f</code>. Давайте попробуем! Мы знаем, что возвращаемый тип `File::open` не является типом `u32`, поэтому давайте изменим выражение `let f` на следующее:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-02-ask-compiler-for-type/src/main.rs:here}}
```

Попытка компиляции выводит сообщение:

```console
{{#include ../listings/ch09-error-handling/no-listing-02-ask-compiler-for-type/output.txt}}
```

Ошибка говорит нам о том, что возвращаемым типом функции `File::open` является `Result<T, E>`. Типовой параметр `T` здесь равен типу успешного выполнения, `std::fs::File`, то есть дескриптору файла. Тип `E`, используемый в значении ошибки, равен `std::io::Error`.

Этот возвращаемый тип означает, что вызов `File::open` может завершиться успешно и вернуть дескриптор файла, с помощью которого можно читать из файла или писать в него. Вызов функции также может завершиться ошибкой: например, файла может не существовать или у нас может не быть прав на доступ к нему. Функция `File::open` должна иметь способ сообщить нам, был ли её вызов успешен или потерпел неудачу и одновременно возвратить либо дескриптор файла либо информацию об ошибке. Эта информация - именно то, что возвращает перечисление `Result`.

Когда вызов `File::open` успешен, значение в переменной `f` будет экземпляром `Ok`, внутри которого содержится дескриптор файла. Если вызов не успешный, значением переменной `f` будет экземпляр `Err`, который содержит больше информации о том, какая ошибка произошла.

Необходимо дописать в код листинга 9-3 выполнение разных действий в зависимости от значения, которое вернёт вызов `File::open`. Листинг 9-4 показывает один из способов обработки `Result` - пользуясь базовым инструментом языка, таким как выражение `match`, рассмотренным в Главе 6.

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-04/src/main.rs}}
```

<span class="caption">Листинг 9-4: Использование выражения <code>match</code> для обработки возвращаемых вариантов типа <code>Result</code></span>

Обратите внимание, что также как перечисление `Option`, перечисление `Result` и его варианты, входят в область видимости благодаря авто-импорту (prelude), поэтому не нужно указывать `Result::` перед использованием вариантов `Ok` и `Err` в ветках выражения `match`.

When the result is `Ok`, this code will return the inner `file` value out of the `Ok` variant, and we then assign that file handle value to the variable `f`. After the `match`, we can use the file handle for reading or writing.

Другая ветвь `match` обрабатывает случай, где мы получаем значение `Err` после вызова `File::open`. В этом примере мы решили вызвать макрос `panic!`. Если в нашей текущей директории нет файла с именем *hello.txt* и мы выполним этот код, то мы увидим следующее сообщение от макроса `panic!`:

```console
{{#include ../listings/ch09-error-handling/listing-09-04/output.txt}}
```

Как обычно, данное сообщение точно говорит, что пошло не так.

### Обработка различных ошибок с помощью match

Код в листинге 9-4 будет вызывать `panic!` независимо от того, почему вызов `File::open` не удался. Однако мы хотим предпринять различные действия для разных причин сбоя. Если открытие `File::open` не удалось из-за отсутствия файла, мы хотим создать файл и вернуть его дескриптор. Если вызов `File::open` не удался по любой другой причине - например, потому что у нас не было прав на открытие файла, то все равно мы хотим вызвать `panic!` как у нас сделано в листинге 9-4. Для этого мы добавляем выражение внутреннего `match`, показанное в листинге 9-5.

<span class="filename">Файл: src/main.rs</span>

<!-- ignore this test because otherwise it creates hello.txt which causes other
tests to fail lol -->

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-05/src/main.rs}}
```

<span class="caption">Листинг 9-5: Обработка различных ошибок разными способами</span>

Типом значения возвращаемого функцией `File::open` внутри `Err` варианта является `io::Error`, структура из стандартной библиотеки. Данная структура имеет метод `kind`, который можно вызвать для получения значения `io::ErrorKind`. Перечисление `io::ErrorKind` из стандартной библиотеки имеет варианты, представляющие различные типы ошибок, которые могут появиться при выполнении операций в `io` (крейте который занимается проблемами ввода/вывода данных). Вариант, который мы хотим использовать, это `ErrorKind::NotFound`. Он даёт информацию, о том, что файл который мы пытаемся открыть ещё не существует. Итак, во второй строке мы вызываем сопоставление шаблона с переменной `f` и попадаем в ветку с обработкой ошибки, но также у нас есть внутренняя проверка для сопоставления `error.kind()` ошибки.

Условие, которое мы хотим проверить во внутреннем `match`, заключается в том, является ли значение, возвращаемое `error.kind()`, вариантом `NotFound` перечисления `ErrorKind`. Если это так, мы пытаемся создать файл с помощью функции `File::create`. Однако, поскольку вызов `File::create` тоже может завершиться ошибкой, нам нужна обработка ещё одной ошибки, теперь уже во внутреннем выражении `match`. Заметьте: если файл не может быть создан, выводится другое, специализированное сообщение об ошибке. Вторая же ветка внешнего `match` (который обрабатывает вызов `error.kind()`), остаётся той же самой - в итоге программа паникует при любой ошибке, кроме ошибки отсутствия файла.

> ### Альтернативы использованию `match` с `Result<T, E>`
>
> Как много `match`! Выражение `match` является очень полезным, но в то же время довольно примитивным. В главе 13 вы узнаете о замыканиях (closures), которые используются во многих методах типа `Result<T, E>`. Эти методы помогают быть более лаконичным, чем использование `match` при работе со значениями `Result<T, E>` в вашем коде.
>
> Например, вот другой способ написать ту же логику, что показана в Листинге 9-5, но с использованием замыканий и метода `unwrap_or_else`:
>
> <!-- CAN'T EXTRACT SEE https://github.com/rust-lang/mdBook/issues/1127 -->
>
> ```rust,ignore
> use std::fs::File;
> use std::io::ErrorKind;
>
> fn main() {
>     let f = File::open("hello.txt").unwrap_or_else(|error| {
>         if error.kind() == ErrorKind::NotFound {
>             File::create("hello.txt").unwrap_or_else(|error| {
>                 panic!("Problem creating the file: {:?}", error);
>             })
>         } else {
>             panic!("Problem opening the file: {:?}", error);
>         }
>     });
> }
> ```
>
> Although this code has the same behavior as Listing 9-5, it doesn’t contain any `match` expressions and is cleaner to read. Come back to this example after you’ve read Chapter 13, and look up the `unwrap_or_else` method in the standard library documentation. Many more of these methods can clean up huge nested `match` expressions when you’re dealing with errors.

### Лаконичные способы обработки ошибок - `unwrap` и `expect`

Использование `match` работает достаточно хорошо, но может быть довольно многословным и не всегда хорошо передаёт смысл. Тип `Result<T, E>` имеет множество вспомогательных методов для выполнения различных, более специфических задач. Метод `unwrap` - это метод быстрого доступа к значениям, реализованный так же, как и выражение `match`, которое мы написали в Листинге 9-4. Если значение `Result` является вариантом `Ok`, `unwrap` возвращает значение внутри `Ok`. Если `Result` - вариант `Err`, то `unwrap` вызовет для нас макрос `panic!`. Вот пример `unwrap` в действии:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-04-unwrap/src/main.rs}}
```

Если мы запустим этот код при отсутствии файла *hello.txt* , то увидим сообщение об ошибке из вызова `panic!` метода `unwrap` :

```text
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error {
repr: Os { code: 2, message: "No such file or directory" } }',
src/libcore/result.rs:906:4
```

Другой метод, похожий на `unwrap`, это `expect`, позволяющий указать сообщение об ошибке для макроса `panic!`. Использование `expect` вместо `unwrap` с предоставлением хорошего сообщения об ошибке выражает ваше намерение и делает более простым отслеживание источника паники. Синтаксис метода `expect` выглядит так:

<span class="filename">Файл: src/main.rs</span>

```rust,should_panic
{{#rustdoc_include ../listings/ch09-error-handling/no-listing-05-expect/src/main.rs}}
```

Мы используем `expect` таким же образом, как и `unwrap`: чтобы вернуть дескриптор файла или вызвать макрос `panic!`. Сообщением об ошибке, которое `expect` передаст в `panic!`, будет параметр функции `expect`, а не значение по умолчанию, используемое `unwrap`. Вот как оно выглядит:

```text
thread 'main' panicked at 'Failed to open hello.txt: Error { repr: Os { code:
2, message: "No such file or directory" } }', src/libcore/result.rs:906:4
```

Так как сообщение об ошибке начинается с нашего пользовательского текста: `Failed to open hello.txt`, то потом будет проще найти из какого места в коде данное сообщение приходит. Если использовать `unwrap` во множестве мест, то придётся потратить время для выяснения какой именно вызов `unwrap` вызывает "панику", так как все вызовы  <code>unwrap</code> генерируют одинаковое сообщение.

### Проброс ошибок

Когда вы пишете функцию, реализация которой вызывает что-то, что может завершиться ошибкой, вместо обработки ошибки в этой функции, вы можете вернуть ошибку в вызывающий код, чтобы он мог решить, что с ней делать. Такой приём известен как *распространение ошибки* (*propagating the error*). Благодаря нему мы даём больше контроля вызывающему коду, где может быть больше информации или логики, которая диктует, как ошибка должна обрабатываться, чем было бы в месте появления этой ошибки.

Например, код программы 9-6 читает имя пользователя из файла. Если файл не существует или не может быть прочтён, то функция возвращает ошибку в код, который вызвал данную функцию:

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-06/src/main.rs:here}}
```

<span class="caption">Листинг 9-6: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>match</code></span>

Данную функцию можно записать гораздо короче. Чтобы больше проникнуться обработкой ошибок, мы сначала сделаем многое самостоятельно, а в конце покажем более короткий способ. Давайте сначала рассмотрим тип возвращаемого значения: `Result<String, io::Error>`. Здесь есть возвращаемое значение функции типа `Result<T, E>` где шаблонный параметр `T` был заполнен конкретным типом `String` и шаблонный параметр `E` был заполнен конкретным типом `io::Error`. Если эта функция выполнится успешно, будет возвращено `Ok`, содержащее значение типа `String` - имя пользователя прочитанное функцией из файла. Если же при чтении файла будут какие-либо проблемы, то вызываемый код получит значение `Err` с экземпляром `io::Error`, в котором содержится больше информации об ошибке. Мы выбрали `io::Error` в качестве возвращаемого значения функции, потому что обе операции, которые мы вызываем внутри этой функции, возвращают этот тип ошибки: функция `File::open` и метод `read_to_string`.

Тело функции начинается с вызова функции `File::open` . Затем мы обрабатываем значение `Result` с `match`, подобным `match` в листинге 9-4. Если `File::open` завершается успешно, дескриптор файла в шаблоне переменной `file` становится значением изменяемой переменной `f`, и функция продолжается. В случае `Err` вместо вызова `panic!`, мы используем ключевое слово `return`, чтобы полностью выйти из функции раньше и передать значение ошибки из `File::open`, теперь уже в переменной шаблона `e`, обратно в вызывающий код в качестве значения ошибки этой функции.

Так если мы создаём новую `String` в переменной `s` и вызываем метод `read_to_string` у дескриптора файла в переменной `f`, чтобы считать содержимое файла в переменную `s`. Метод `read_to_string` также возвращает `Result`, потому что он может потерпеть неудачу, даже если `File::open` пройдёт успешно. Таким образом, нам нужно ещё одно выражение `match`, чтобы справиться с этим `Result`: если `read_to_string` выполнится успешно, то наша функция завершится успешно и мы вернём имя пользователя из файла, которое сейчас находится в `s`, завёрнутым в `Ok`. Если вызов `read_to_string` не успешен, мы возвращаем значение ошибки так же, как мы вернули значение ошибки в `match`, обработавшем возвращаемое значение `File::open`. Тем не менее, нам не нужно явно писать `return`, потому что это последнее выражение в функции.

Затем код, вызывающий этот, будет обрабатывать получение либо значения `Ok`, содержащего имя пользователя, либо значения `Err`, содержащего `io::Error`. Вызывающий код должен решить, что делать с этими значениями. Если вызывающий код получает значение `Err`, он может вызвать `panic!` и завершить работу программы, использовать имя пользователя по умолчанию или найти имя пользователя, например, не в файле. У нас недостаточно информации о том, что на самом деле пытается сделать вызывающий код, поэтому мы распространяем всю информацию об успехах или ошибках вверх, чтобы она могла обрабатываться соответствующим образом.

Такая схема распространения ошибок настолько распространена в Rust, что Rust предоставляет оператор вопросительный знак `?` для простоты.

#### Сокращение для проброса ошибок: оператор `?`

Код программы 9-6 показывает реализацию функции `read_username_from_file`, функционал которой аналогичен коду программы 9-5, но реализация использует оператор `?`:

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-07/src/main.rs:here}}
```

<span class="caption">Листинг 9-7: Функция, которая возвращает ошибки в вызывающий код, используя оператор <code>?</code></span>

Оператор `?`, помещаемый после значения типа `Result`, работает почти таким же образом, как выражение `match`, которое мы определили для обработки значений типа `Result` в листинге 9-6. Если значение `Result` равно `Ok`, значение внутри `Ok` будет возвращено из этого выражения и программа продолжит выполнение. Если значение является `Err`, то `Err` будет возвращено из всей функции, как если бы мы использовали ключевое слово `return`, таким образом ошибка передаётся в вызывающий код.

Существует разница между тем, что делает выражение `match` из листинга 9.6, и тем, что делает `?` оператор делает: значения ошибок, которые имеют `?` операторы, вызываемые на них, проходят через функцию `from`, определенную в свойстве `From` в стандартной библиотеке, которая используется для преобразования ошибок из одного типа в другой. Когда `?` оператор вызывает функцию `from`, полученный тип ошибки преобразуется в тип ошибки, определенный в возвращаемом типе текущей функции. Это полезно, когда функция возвращает один тип ошибки, чтобы представить все способы, которыми функция может дать сбой, даже если некоторые части могут выйти из строя по разным причинам. Пока существует `impl From<OtherError> for ReturnedError`, чтобы определить преобразование в функции `from` типажа, `?` оператор позаботится об автоматическом вызове функции `from`.

В коде примера 9-7 оператор `?` в конце вызова функции `File::open` возвращает значения содержимого `Ok` в переменную `f`. Если же в при работе этой функции произошла ошибка, оператор `?` произведёт ранний возврат из функции со значением `Err`. То же касается `?` в конце вызова `read_to_string`.

Использование оператора `?` позволят уменьшить количество строк кода и сделать реализацию проще. Написанный в предыдущем примере код можно сделать ещё короче с помощью сокращения промежуточных переменных и конвейерного вызова нескольких методов подряд, как показано в листинге 9-8:

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-08/src/main.rs:here}}
```

<span class="caption">Listing 9-8: Chaining method calls after the <code>?</code> operator</span>

Мы перенесли в начало функции создание новой переменной `s` типа `String`; эта часть не изменилась. Вместо создания переменной `f` мы добавили вызов `read_to_string` непосредственно к результату `File::open("hello.txt")?`, У нас ещё есть `?` в конце вызова `read_to_string`, и мы по-прежнему возвращаем значение `Ok`, содержащее имя пользователя в `s` когда оба метода: `File::open` и `read_to_string` успешны, а не возвращают ошибки. Функциональность снова такая же, как в листинге 9-6 и листинге 9-7; это просто другой, более эргономичный способ решения той же задачи.

Продолжая рассматривать разные способы записи данной функции, листинг 9-9 демонстрирует способ сделать её ещё короче.

<span class="filename">Файл: src/main.rs</span>

<!-- Deliberately not using rustdoc_include here; the `main` function in the
file panics. We do want to include it for reader experimentation purposes, but
don't want to include it for rustdoc testing purposes. -->

```rust
{{#include ../listings/ch09-error-handling/listing-09-09/src/main.rs:here}}
```

<span class="caption">Листинг 9-9: Использование <code>fs::read_to_string</code> вместо открытия и чтения файла</span>

Чтение файла в строку довольно распространённая операция, так что стандартная библиотека предоставляет удобную функцию `fs::read_to_string`, которая открывает файл, создаёт новую `String`, читает содержимое файла, размещает его в `String` и возвращает её. Конечно, использование функции `fs::read_to_string` не даёт возможности объяснить обработку всех ошибок, поэтому мы сначала изучили длинный способ.

#### Где можно использовать оперетор `?`

`?` может использоваться только в функциях, тип возвращаемого значения которых совместим со значением `?` используется на. Это потому, что `?` оператор определен для выполнения раннего возврата значения из функции таким же образом, как и выражение `match`, которое мы определили в листинге 9-6. В листинге 9-6 `match` использовало значение `Result`, а ответвление с ранним возвратом вернуло значение `Err(e)`. Тип возвращаемого значения функции должен быть `Result`, чтобы он был совместим с этим `return`.

В листинге 9-10 давайте посмотрим на ошибку, которую мы получим, если воспользуемся `?` оператор в `main` функции с типом возвращаемого значения, несовместимым с типом используемого нами значения `?` на:

```rust,ignore,does_not_compile
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-10/src/main.rs}}
```

<span class="caption">Листинг 9-10: Попытка использовать <code>?</code> в <code>main</code> функции, которая возвращает <code>()</code> , не будет компилироваться</span>

Этот код открывает файл, что может привести к сбою. `?` оператор следует за значением `Result` , возвращаемым `File::open` , но эта `main` функция имеет возвращаемый тип `()` , а не `Result` . Когда мы компилируем этот код, мы получаем следующее сообщение об ошибке:

```console
{{#include ../listings/ch09-error-handling/listing-09-10/output.txt}}
```

Эта ошибка указывает на то, что нам разрешено использовать только `?` оператор в функции, которая возвращает `Result` , `Option` или другой тип, реализующий `FromResidual` . Чтобы исправить ошибку, у вас есть два варианта. Один из вариантов — изменить возвращаемый тип вашей функции, чтобы он был совместим со значением, которое вы используете `?` оператора, если у вас нет ограничений, препятствующих этому. Другой метод заключается в использовании `match` или одного из методов `Result<T, E>` для обработки `Result<T, E>` любым подходящим способом.

В сообщении об ошибке также упоминалось, что `?` также может использоваться со значениями `Option<T>` . Как с использованием `?` в `Result` вы можете использовать только `?` on `Option` в функции, которая возвращает `Option` . Поведение `?` оператор при вызове для `Option<T>` подобен его поведению при вызове для `Result<T, E>` : если значение равно `None` , `None` будет возвращено раньше из функции в этой точке. Если значение равно `Some` , значение внутри `Some` является результирующим значением выражения, и функция продолжает работу. В листинге 9-11 приведен пример функции, которая находит последний символ первой строки заданного текста:

```rust
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-11/src/main.rs:here}}
```

<span class="caption">Листинг 9-11: Использование <code>?</code> оператор значения <code>Option&lt;T&gt;</code></span>

Эта функция возвращает `Option<char>` , потому что возможно, что там есть символ, но также возможно, что его нет. Этот код принимает аргумент среза `text` строки и вызывает для него метод `lines` , который возвращает итератор для строк в строке. Поскольку эта функция хочет проверить первую строку, она вызывает `next` у итератора, чтобы получить первое значение от итератора. Если `text` является пустой строкой, этот вызов `next` вернет `None` , и в этом случае мы используем `?` чтобы остановить и вернуть `None` из `last_char_of_first_line` . Если `text` не является пустой строкой, `next` вернет значение `Some` , содержащее фрагмент строки первой строки в `text` .

Символ `?` извлекает фрагмент строки, и мы можем вызвать `chars` для этого фрагмента строки. чтобы получить итератор символов. Нас интересует последний символ в первой строке, поэтому мы вызываем `last`, чтобы вернуть последний элемент в итераторе. Вернётся `Option`, потому что возможно, что первая строка пустая - например, если `text` начинается с пустой строки, но имеет символы в других строках, как в `"\nhi"`. Однако, если в первой строке есть последний символ, он будет возвращён в варианте `Some`. Оператор `?` в середине даёт нам лаконичный способ выразить эту логику, позволяя реализовать функцию в одной строке. Если бы мы не могли использовать оператор `?` в `Option`, нам пришлось бы пришлось бы реализовать эту логику, используя больше вызовов методов или выражение `match`.

Обратите внимание, что вы можете использовать `?` оператор `Result` в функции, которая возвращает `Result` , и вы можете использовать оператор `?` оператор на `Option` в функции, которая возвращает `Option` , но вы не можете смешивать и сопоставлять. `?` оператор не будет автоматически преобразовывать `Result` в `Option` или наоборот; в этих случаях вы можете использовать такие методы, как метод `ok` для `Result` или метод `ok_or` для `Option` , чтобы выполнить преобразование явно.

До сих пор мы использовали все `main` функции return `()` . `main` функция особенная, потому что это точка входа и выхода исполняемых программ, и существуют ограничения на тип возвращаемого значения, чтобы программы вели себя должным образом.

К счастью, `main` также может возвращать `Result<(), E>` . В листинге 9-12 используется код из листинга 9-10, но мы изменили возвращаемый тип `main` на `Result<(), Box<dyn Error>>` и добавили возвращаемое значение `Ok(())` в конец. Теперь этот код будет скомпилирован:

```rust,ignore
{{#rustdoc_include ../listings/ch09-error-handling/listing-09-12/src/main.rs}}
```

<span class="caption">Листинг 9-12: Замена <code>main</code> на return <code>Result&lt;(), E&gt;</code> позволяет использовать оператор <code>?</code> оператор над значениями <code>Result</code></span>

Тип `Box<dyn Error>` — это *трейт-объект* , о котором мы поговорим в разделе [«Использование трейт-объектов, допускающих значения разных типов»](ch17-02-trait-objects.html#using-trait-objects-that-allow-for-values-of-different-types)<!-- игнорировать --> в главе 17. На данный момент вы можете читать `Box<dyn Error>` как «любую ошибку». Использование `?` для значения `Result` в `main` функции с типом ошибки `Box<dyn Error>` допускается, так как это позволяет досрочно возвращать любое значение `Err` .

Когда `main` функция возвращает `Result<(), E>` , исполняемый файл завершится со значением `0` , если `main` вернет `Ok(())` , и выйдет с ненулевым значением, если `main` вернет значение `Err` . Исполняемые файлы, написанные на C, при выходе возвращают целые числа: успешно завершенные программы возвращают целое число `0` , а программы с ошибкой возвращают целое число, отличное от `0` . Rust также возвращает целые числа из исполняемых файлов, чтобы быть совместимым с этим соглашением.

`main` функция может возвращать любые типы, реализующие [`std::process::Termination` .](../std/process/trait.Termination.html)<!-- игнорировать -->. На момент написания этой статьи `Termination` был нестабильной функцией, доступной только в Nightly Rust, поэтому вы пока не можете реализовать ее для своих типов в Stable Rust, но, возможно, когда-нибудь сможете!

Теперь, когда мы обсудили детали вызова `panic!` или возврата `Result`, давайте вернёмся к тому, как решить, какой из случаев подходит для какой ситуации.
